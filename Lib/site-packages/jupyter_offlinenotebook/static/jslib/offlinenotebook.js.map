{"version":3,"file":"offlinenotebook.js","mappings":"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","sources":["webpack://jupyter-offlinenotebook/webpack/bootstrap","webpack://jupyter-offlinenotebook/webpack/runtime/define property getters","webpack://jupyter-offlinenotebook/webpack/runtime/hasOwnProperty shorthand","webpack://jupyter-offlinenotebook/webpack/runtime/make namespace object","webpack://jupyter-offlinenotebook/./node_modules/dexie/dist/modern/dexie.mjs","webpack://jupyter-offlinenotebook/./lib/jslib/offlinenotebook.js"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\n * Dexie.js - a minimalistic wrapper for IndexedDB\n * ===============================================\n *\n * By David Fahlander, david.fahlander@gmail.com\n *\n * Version 3.2.0, Thu Nov 18 2021\n *\n * http://dexie.org\n *\n * Apache License Version 2.0, January 2004, http://www.apache.org/licenses/\n */\n \nconst _global = typeof globalThis !== 'undefined' ? globalThis :\n    typeof self !== 'undefined' ? self :\n        typeof window !== 'undefined' ? window :\n            global;\n\nconst keys = Object.keys;\nconst isArray = Array.isArray;\nif (typeof Promise !== 'undefined' && !_global.Promise) {\n    _global.Promise = Promise;\n}\nfunction extend(obj, extension) {\n    if (typeof extension !== 'object')\n        return obj;\n    keys(extension).forEach(function (key) {\n        obj[key] = extension[key];\n    });\n    return obj;\n}\nconst getProto = Object.getPrototypeOf;\nconst _hasOwn = {}.hasOwnProperty;\nfunction hasOwn(obj, prop) {\n    return _hasOwn.call(obj, prop);\n}\nfunction props(proto, extension) {\n    if (typeof extension === 'function')\n        extension = extension(getProto(proto));\n    (typeof Reflect === \"undefined\" ? keys : Reflect.ownKeys)(extension).forEach(key => {\n        setProp(proto, key, extension[key]);\n    });\n}\nconst defineProperty = Object.defineProperty;\nfunction setProp(obj, prop, functionOrGetSet, options) {\n    defineProperty(obj, prop, extend(functionOrGetSet && hasOwn(functionOrGetSet, \"get\") && typeof functionOrGetSet.get === 'function' ?\n        { get: functionOrGetSet.get, set: functionOrGetSet.set, configurable: true } :\n        { value: functionOrGetSet, configurable: true, writable: true }, options));\n}\nfunction derive(Child) {\n    return {\n        from: function (Parent) {\n            Child.prototype = Object.create(Parent.prototype);\n            setProp(Child.prototype, \"constructor\", Child);\n            return {\n                extend: props.bind(null, Child.prototype)\n            };\n        }\n    };\n}\nconst getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nfunction getPropertyDescriptor(obj, prop) {\n    const pd = getOwnPropertyDescriptor(obj, prop);\n    let proto;\n    return pd || (proto = getProto(obj)) && getPropertyDescriptor(proto, prop);\n}\nconst _slice = [].slice;\nfunction slice(args, start, end) {\n    return _slice.call(args, start, end);\n}\nfunction override(origFunc, overridedFactory) {\n    return overridedFactory(origFunc);\n}\nfunction assert(b) {\n    if (!b)\n        throw new Error(\"Assertion Failed\");\n}\nfunction asap$1(fn) {\n    if (_global.setImmediate)\n        setImmediate(fn);\n    else\n        setTimeout(fn, 0);\n}\nfunction arrayToObject(array, extractor) {\n    return array.reduce((result, item, i) => {\n        var nameAndValue = extractor(item, i);\n        if (nameAndValue)\n            result[nameAndValue[0]] = nameAndValue[1];\n        return result;\n    }, {});\n}\nfunction tryCatch(fn, onerror, args) {\n    try {\n        fn.apply(null, args);\n    }\n    catch (ex) {\n        onerror && onerror(ex);\n    }\n}\nfunction getByKeyPath(obj, keyPath) {\n    if (hasOwn(obj, keyPath))\n        return obj[keyPath];\n    if (!keyPath)\n        return obj;\n    if (typeof keyPath !== 'string') {\n        var rv = [];\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            var val = getByKeyPath(obj, keyPath[i]);\n            rv.push(val);\n        }\n        return rv;\n    }\n    var period = keyPath.indexOf('.');\n    if (period !== -1) {\n        var innerObj = obj[keyPath.substr(0, period)];\n        return innerObj === undefined ? undefined : getByKeyPath(innerObj, keyPath.substr(period + 1));\n    }\n    return undefined;\n}\nfunction setByKeyPath(obj, keyPath, value) {\n    if (!obj || keyPath === undefined)\n        return;\n    if ('isFrozen' in Object && Object.isFrozen(obj))\n        return;\n    if (typeof keyPath !== 'string' && 'length' in keyPath) {\n        assert(typeof value !== 'string' && 'length' in value);\n        for (var i = 0, l = keyPath.length; i < l; ++i) {\n            setByKeyPath(obj, keyPath[i], value[i]);\n        }\n    }\n    else {\n        var period = keyPath.indexOf('.');\n        if (period !== -1) {\n            var currentKeyPath = keyPath.substr(0, period);\n            var remainingKeyPath = keyPath.substr(period + 1);\n            if (remainingKeyPath === \"\")\n                if (value === undefined) {\n                    if (isArray(obj) && !isNaN(parseInt(currentKeyPath)))\n                        obj.splice(currentKeyPath, 1);\n                    else\n                        delete obj[currentKeyPath];\n                }\n                else\n                    obj[currentKeyPath] = value;\n            else {\n                var innerObj = obj[currentKeyPath];\n                if (!innerObj)\n                    innerObj = (obj[currentKeyPath] = {});\n                setByKeyPath(innerObj, remainingKeyPath, value);\n            }\n        }\n        else {\n            if (value === undefined) {\n                if (isArray(obj) && !isNaN(parseInt(keyPath)))\n                    obj.splice(keyPath, 1);\n                else\n                    delete obj[keyPath];\n            }\n            else\n                obj[keyPath] = value;\n        }\n    }\n}\nfunction delByKeyPath(obj, keyPath) {\n    if (typeof keyPath === 'string')\n        setByKeyPath(obj, keyPath, undefined);\n    else if ('length' in keyPath)\n        [].map.call(keyPath, function (kp) {\n            setByKeyPath(obj, kp, undefined);\n        });\n}\nfunction shallowClone(obj) {\n    var rv = {};\n    for (var m in obj) {\n        if (hasOwn(obj, m))\n            rv[m] = obj[m];\n    }\n    return rv;\n}\nconst concat = [].concat;\nfunction flatten(a) {\n    return concat.apply([], a);\n}\nconst intrinsicTypeNames = \"Boolean,String,Date,RegExp,Blob,File,FileList,FileSystemFileHandle,ArrayBuffer,DataView,Uint8ClampedArray,ImageBitmap,ImageData,Map,Set,CryptoKey\"\n    .split(',').concat(flatten([8, 16, 32, 64].map(num => [\"Int\", \"Uint\", \"Float\"].map(t => t + num + \"Array\")))).filter(t => _global[t]);\nconst intrinsicTypes = intrinsicTypeNames.map(t => _global[t]);\narrayToObject(intrinsicTypeNames, x => [x, true]);\nlet circularRefs = null;\nfunction deepClone(any) {\n    circularRefs = typeof WeakMap !== 'undefined' && new WeakMap();\n    const rv = innerDeepClone(any);\n    circularRefs = null;\n    return rv;\n}\nfunction innerDeepClone(any) {\n    if (!any || typeof any !== 'object')\n        return any;\n    let rv = circularRefs && circularRefs.get(any);\n    if (rv)\n        return rv;\n    if (isArray(any)) {\n        rv = [];\n        circularRefs && circularRefs.set(any, rv);\n        for (var i = 0, l = any.length; i < l; ++i) {\n            rv.push(innerDeepClone(any[i]));\n        }\n    }\n    else if (intrinsicTypes.indexOf(any.constructor) >= 0) {\n        rv = any;\n    }\n    else {\n        const proto = getProto(any);\n        rv = proto === Object.prototype ? {} : Object.create(proto);\n        circularRefs && circularRefs.set(any, rv);\n        for (var prop in any) {\n            if (hasOwn(any, prop)) {\n                rv[prop] = innerDeepClone(any[prop]);\n            }\n        }\n    }\n    return rv;\n}\nconst { toString } = {};\nfunction toStringTag(o) {\n    return toString.call(o).slice(8, -1);\n}\nconst iteratorSymbol = typeof Symbol !== 'undefined' ?\n    Symbol.iterator :\n    '@@iterator';\nconst getIteratorOf = typeof iteratorSymbol === \"symbol\" ? function (x) {\n    var i;\n    return x != null && (i = x[iteratorSymbol]) && i.apply(x);\n} : function () { return null; };\nconst NO_CHAR_ARRAY = {};\nfunction getArrayOf(arrayLike) {\n    var i, a, x, it;\n    if (arguments.length === 1) {\n        if (isArray(arrayLike))\n            return arrayLike.slice();\n        if (this === NO_CHAR_ARRAY && typeof arrayLike === 'string')\n            return [arrayLike];\n        if ((it = getIteratorOf(arrayLike))) {\n            a = [];\n            while ((x = it.next()), !x.done)\n                a.push(x.value);\n            return a;\n        }\n        if (arrayLike == null)\n            return [arrayLike];\n        i = arrayLike.length;\n        if (typeof i === 'number') {\n            a = new Array(i);\n            while (i--)\n                a[i] = arrayLike[i];\n            return a;\n        }\n        return [arrayLike];\n    }\n    i = arguments.length;\n    a = new Array(i);\n    while (i--)\n        a[i] = arguments[i];\n    return a;\n}\nconst isAsyncFunction = typeof Symbol !== 'undefined'\n    ? (fn) => fn[Symbol.toStringTag] === 'AsyncFunction'\n    : () => false;\n\nvar debug = typeof location !== 'undefined' &&\n    /^(http|https):\\/\\/(localhost|127\\.0\\.0\\.1)/.test(location.href);\nfunction setDebug(value, filter) {\n    debug = value;\n    libraryFilter = filter;\n}\nvar libraryFilter = () => true;\nconst NEEDS_THROW_FOR_STACK = !new Error(\"\").stack;\nfunction getErrorWithStack() {\n    if (NEEDS_THROW_FOR_STACK)\n        try {\n            getErrorWithStack.arguments;\n            throw new Error();\n        }\n        catch (e) {\n            return e;\n        }\n    return new Error();\n}\nfunction prettyStack(exception, numIgnoredFrames) {\n    var stack = exception.stack;\n    if (!stack)\n        return \"\";\n    numIgnoredFrames = (numIgnoredFrames || 0);\n    if (stack.indexOf(exception.name) === 0)\n        numIgnoredFrames += (exception.name + exception.message).split('\\n').length;\n    return stack.split('\\n')\n        .slice(numIgnoredFrames)\n        .filter(libraryFilter)\n        .map(frame => \"\\n\" + frame)\n        .join('');\n}\n\nvar dexieErrorNames = [\n    'Modify',\n    'Bulk',\n    'OpenFailed',\n    'VersionChange',\n    'Schema',\n    'Upgrade',\n    'InvalidTable',\n    'MissingAPI',\n    'NoSuchDatabase',\n    'InvalidArgument',\n    'SubTransaction',\n    'Unsupported',\n    'Internal',\n    'DatabaseClosed',\n    'PrematureCommit',\n    'ForeignAwait'\n];\nvar idbDomErrorNames = [\n    'Unknown',\n    'Constraint',\n    'Data',\n    'TransactionInactive',\n    'ReadOnly',\n    'Version',\n    'NotFound',\n    'InvalidState',\n    'InvalidAccess',\n    'Abort',\n    'Timeout',\n    'QuotaExceeded',\n    'Syntax',\n    'DataClone'\n];\nvar errorList = dexieErrorNames.concat(idbDomErrorNames);\nvar defaultTexts = {\n    VersionChanged: \"Database version changed by other database connection\",\n    DatabaseClosed: \"Database has been closed\",\n    Abort: \"Transaction aborted\",\n    TransactionInactive: \"Transaction has already completed or failed\",\n    MissingAPI: \"IndexedDB API missing. Please visit https://tinyurl.com/y2uuvskb\"\n};\nfunction DexieError(name, msg) {\n    this._e = getErrorWithStack();\n    this.name = name;\n    this.message = msg;\n}\nderive(DexieError).from(Error).extend({\n    stack: {\n        get: function () {\n            return this._stack ||\n                (this._stack = this.name + \": \" + this.message + prettyStack(this._e, 2));\n        }\n    },\n    toString: function () { return this.name + \": \" + this.message; }\n});\nfunction getMultiErrorMessage(msg, failures) {\n    return msg + \". Errors: \" + Object.keys(failures)\n        .map(key => failures[key].toString())\n        .filter((v, i, s) => s.indexOf(v) === i)\n        .join('\\n');\n}\nfunction ModifyError(msg, failures, successCount, failedKeys) {\n    this._e = getErrorWithStack();\n    this.failures = failures;\n    this.failedKeys = failedKeys;\n    this.successCount = successCount;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(ModifyError).from(DexieError);\nfunction BulkError(msg, failures) {\n    this._e = getErrorWithStack();\n    this.name = \"BulkError\";\n    this.failures = Object.keys(failures).map(pos => failures[pos]);\n    this.failuresByPos = failures;\n    this.message = getMultiErrorMessage(msg, failures);\n}\nderive(BulkError).from(DexieError);\nvar errnames = errorList.reduce((obj, name) => (obj[name] = name + \"Error\", obj), {});\nconst BaseException = DexieError;\nvar exceptions = errorList.reduce((obj, name) => {\n    var fullName = name + \"Error\";\n    function DexieError(msgOrInner, inner) {\n        this._e = getErrorWithStack();\n        this.name = fullName;\n        if (!msgOrInner) {\n            this.message = defaultTexts[name] || fullName;\n            this.inner = null;\n        }\n        else if (typeof msgOrInner === 'string') {\n            this.message = `${msgOrInner}${!inner ? '' : '\\n ' + inner}`;\n            this.inner = inner || null;\n        }\n        else if (typeof msgOrInner === 'object') {\n            this.message = `${msgOrInner.name} ${msgOrInner.message}`;\n            this.inner = msgOrInner;\n        }\n    }\n    derive(DexieError).from(BaseException);\n    obj[name] = DexieError;\n    return obj;\n}, {});\nexceptions.Syntax = SyntaxError;\nexceptions.Type = TypeError;\nexceptions.Range = RangeError;\nvar exceptionMap = idbDomErrorNames.reduce((obj, name) => {\n    obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfunction mapError(domError, message) {\n    if (!domError || domError instanceof DexieError || domError instanceof TypeError || domError instanceof SyntaxError || !domError.name || !exceptionMap[domError.name])\n        return domError;\n    var rv = new exceptionMap[domError.name](message || domError.message, domError);\n    if (\"stack\" in domError) {\n        setProp(rv, \"stack\", { get: function () {\n                return this.inner.stack;\n            } });\n    }\n    return rv;\n}\nvar fullNameExceptions = errorList.reduce((obj, name) => {\n    if ([\"Syntax\", \"Type\", \"Range\"].indexOf(name) === -1)\n        obj[name + \"Error\"] = exceptions[name];\n    return obj;\n}, {});\nfullNameExceptions.ModifyError = ModifyError;\nfullNameExceptions.DexieError = DexieError;\nfullNameExceptions.BulkError = BulkError;\n\nfunction nop() { }\nfunction mirror(val) { return val; }\nfunction pureFunctionChain(f1, f2) {\n    if (f1 == null || f1 === mirror)\n        return f2;\n    return function (val) {\n        return f2(f1(val));\n    };\n}\nfunction callBoth(on1, on2) {\n    return function () {\n        on1.apply(this, arguments);\n        on2.apply(this, arguments);\n    };\n}\nfunction hookCreatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res !== undefined)\n            arguments[0] = res;\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res2 !== undefined ? res2 : res;\n    };\n}\nfunction hookDeletingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        f1.apply(this, arguments);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = this.onerror = null;\n        f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n    };\n}\nfunction hookUpdatingChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function (modifications) {\n        var res = f1.apply(this, arguments);\n        extend(modifications, res);\n        var onsuccess = this.onsuccess,\n        onerror = this.onerror;\n        this.onsuccess = null;\n        this.onerror = null;\n        var res2 = f2.apply(this, arguments);\n        if (onsuccess)\n            this.onsuccess = this.onsuccess ? callBoth(onsuccess, this.onsuccess) : onsuccess;\n        if (onerror)\n            this.onerror = this.onerror ? callBoth(onerror, this.onerror) : onerror;\n        return res === undefined ?\n            (res2 === undefined ? undefined : res2) :\n            (extend(res, res2));\n    };\n}\nfunction reverseStoppableEventChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        if (f2.apply(this, arguments) === false)\n            return false;\n        return f1.apply(this, arguments);\n    };\n}\nfunction promisableChain(f1, f2) {\n    if (f1 === nop)\n        return f2;\n    return function () {\n        var res = f1.apply(this, arguments);\n        if (res && typeof res.then === 'function') {\n            var thiz = this, i = arguments.length, args = new Array(i);\n            while (i--)\n                args[i] = arguments[i];\n            return res.then(function () {\n                return f2.apply(thiz, args);\n            });\n        }\n        return f2.apply(this, arguments);\n    };\n}\n\nvar INTERNAL = {};\nconst LONG_STACKS_CLIP_LIMIT = 100,\nMAX_LONG_STACKS = 20, ZONE_ECHO_LIMIT = 100, [resolvedNativePromise, nativePromiseProto, resolvedGlobalPromise] = typeof Promise === 'undefined' ?\n    [] :\n    (() => {\n        let globalP = Promise.resolve();\n        if (typeof crypto === 'undefined' || !crypto.subtle)\n            return [globalP, getProto(globalP), globalP];\n        const nativeP = crypto.subtle.digest(\"SHA-512\", new Uint8Array([0]));\n        return [\n            nativeP,\n            getProto(nativeP),\n            globalP\n        ];\n    })(), nativePromiseThen = nativePromiseProto && nativePromiseProto.then;\nconst NativePromise = resolvedNativePromise && resolvedNativePromise.constructor;\nconst patchGlobalPromise = !!resolvedGlobalPromise;\nvar stack_being_generated = false;\nvar schedulePhysicalTick = resolvedGlobalPromise ?\n    () => { resolvedGlobalPromise.then(physicalTick); }\n    :\n        _global.setImmediate ?\n            setImmediate.bind(null, physicalTick) :\n            _global.MutationObserver ?\n                () => {\n                    var hiddenDiv = document.createElement(\"div\");\n                    (new MutationObserver(() => {\n                        physicalTick();\n                        hiddenDiv = null;\n                    })).observe(hiddenDiv, { attributes: true });\n                    hiddenDiv.setAttribute('i', '1');\n                } :\n                () => { setTimeout(physicalTick, 0); };\nvar asap = function (callback, args) {\n    microtickQueue.push([callback, args]);\n    if (needsNewPhysicalTick) {\n        schedulePhysicalTick();\n        needsNewPhysicalTick = false;\n    }\n};\nvar isOutsideMicroTick = true,\nneedsNewPhysicalTick = true,\nunhandledErrors = [],\nrejectingErrors = [],\ncurrentFulfiller = null, rejectionMapper = mirror;\nvar globalPSD = {\n    id: 'global',\n    global: true,\n    ref: 0,\n    unhandleds: [],\n    onunhandled: globalError,\n    pgp: false,\n    env: {},\n    finalize: function () {\n        this.unhandleds.forEach(uh => {\n            try {\n                globalError(uh[0], uh[1]);\n            }\n            catch (e) { }\n        });\n    }\n};\nvar PSD = globalPSD;\nvar microtickQueue = [];\nvar numScheduledCalls = 0;\nvar tickFinalizers = [];\nfunction DexiePromise(fn) {\n    if (typeof this !== 'object')\n        throw new TypeError('Promises must be constructed via new');\n    this._listeners = [];\n    this.onuncatched = nop;\n    this._lib = false;\n    var psd = (this._PSD = PSD);\n    if (debug) {\n        this._stackHolder = getErrorWithStack();\n        this._prev = null;\n        this._numPrev = 0;\n    }\n    if (typeof fn !== 'function') {\n        if (fn !== INTERNAL)\n            throw new TypeError('Not a function');\n        this._state = arguments[1];\n        this._value = arguments[2];\n        if (this._state === false)\n            handleRejection(this, this._value);\n        return;\n    }\n    this._state = null;\n    this._value = null;\n    ++psd.ref;\n    executePromiseTask(this, fn);\n}\nconst thenProp = {\n    get: function () {\n        var psd = PSD, microTaskId = totalEchoes;\n        function then(onFulfilled, onRejected) {\n            var possibleAwait = !psd.global && (psd !== PSD || microTaskId !== totalEchoes);\n            const cleanup = possibleAwait && !decrementExpectedAwaits();\n            var rv = new DexiePromise((resolve, reject) => {\n                propagateToListener(this, new Listener(nativeAwaitCompatibleWrap(onFulfilled, psd, possibleAwait, cleanup), nativeAwaitCompatibleWrap(onRejected, psd, possibleAwait, cleanup), resolve, reject, psd));\n            });\n            debug && linkToPreviousPromise(rv, this);\n            return rv;\n        }\n        then.prototype = INTERNAL;\n        return then;\n    },\n    set: function (value) {\n        setProp(this, 'then', value && value.prototype === INTERNAL ?\n            thenProp :\n            {\n                get: function () {\n                    return value;\n                },\n                set: thenProp.set\n            });\n    }\n};\nprops(DexiePromise.prototype, {\n    then: thenProp,\n    _then: function (onFulfilled, onRejected) {\n        propagateToListener(this, new Listener(null, null, onFulfilled, onRejected, PSD));\n    },\n    catch: function (onRejected) {\n        if (arguments.length === 1)\n            return this.then(null, onRejected);\n        var type = arguments[0], handler = arguments[1];\n        return typeof type === 'function' ? this.then(null, err =>\n        err instanceof type ? handler(err) : PromiseReject(err))\n            : this.then(null, err =>\n            err && err.name === type ? handler(err) : PromiseReject(err));\n    },\n    finally: function (onFinally) {\n        return this.then(value => {\n            onFinally();\n            return value;\n        }, err => {\n            onFinally();\n            return PromiseReject(err);\n        });\n    },\n    stack: {\n        get: function () {\n            if (this._stack)\n                return this._stack;\n            try {\n                stack_being_generated = true;\n                var stacks = getStack(this, [], MAX_LONG_STACKS);\n                var stack = stacks.join(\"\\nFrom previous: \");\n                if (this._state !== null)\n                    this._stack = stack;\n                return stack;\n            }\n            finally {\n                stack_being_generated = false;\n            }\n        }\n    },\n    timeout: function (ms, msg) {\n        return ms < Infinity ?\n            new DexiePromise((resolve, reject) => {\n                var handle = setTimeout(() => reject(new exceptions.Timeout(msg)), ms);\n                this.then(resolve, reject).finally(clearTimeout.bind(null, handle));\n            }) : this;\n    }\n});\nif (typeof Symbol !== 'undefined' && Symbol.toStringTag)\n    setProp(DexiePromise.prototype, Symbol.toStringTag, 'Dexie.Promise');\nglobalPSD.env = snapShot();\nfunction Listener(onFulfilled, onRejected, resolve, reject, zone) {\n    this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;\n    this.onRejected = typeof onRejected === 'function' ? onRejected : null;\n    this.resolve = resolve;\n    this.reject = reject;\n    this.psd = zone;\n}\nprops(DexiePromise, {\n    all: function () {\n        var values = getArrayOf.apply(null, arguments)\n            .map(onPossibleParallellAsync);\n        return new DexiePromise(function (resolve, reject) {\n            if (values.length === 0)\n                resolve([]);\n            var remaining = values.length;\n            values.forEach((a, i) => DexiePromise.resolve(a).then(x => {\n                values[i] = x;\n                if (!--remaining)\n                    resolve(values);\n            }, reject));\n        });\n    },\n    resolve: value => {\n        if (value instanceof DexiePromise)\n            return value;\n        if (value && typeof value.then === 'function')\n            return new DexiePromise((resolve, reject) => {\n                value.then(resolve, reject);\n            });\n        var rv = new DexiePromise(INTERNAL, true, value);\n        linkToPreviousPromise(rv, currentFulfiller);\n        return rv;\n    },\n    reject: PromiseReject,\n    race: function () {\n        var values = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n        return new DexiePromise((resolve, reject) => {\n            values.map(value => DexiePromise.resolve(value).then(resolve, reject));\n        });\n    },\n    PSD: {\n        get: () => PSD,\n        set: value => PSD = value\n    },\n    totalEchoes: { get: () => totalEchoes },\n    newPSD: newScope,\n    usePSD: usePSD,\n    scheduler: {\n        get: () => asap,\n        set: value => { asap = value; }\n    },\n    rejectionMapper: {\n        get: () => rejectionMapper,\n        set: value => { rejectionMapper = value; }\n    },\n    follow: (fn, zoneProps) => {\n        return new DexiePromise((resolve, reject) => {\n            return newScope((resolve, reject) => {\n                var psd = PSD;\n                psd.unhandleds = [];\n                psd.onunhandled = reject;\n                psd.finalize = callBoth(function () {\n                    run_at_end_of_this_or_next_physical_tick(() => {\n                        this.unhandleds.length === 0 ? resolve() : reject(this.unhandleds[0]);\n                    });\n                }, psd.finalize);\n                fn();\n            }, zoneProps, resolve, reject);\n        });\n    }\n});\nif (NativePromise) {\n    if (NativePromise.allSettled)\n        setProp(DexiePromise, \"allSettled\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise(resolve => {\n                if (possiblePromises.length === 0)\n                    resolve([]);\n                let remaining = possiblePromises.length;\n                const results = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => results[i] = { status: \"fulfilled\", value }, reason => results[i] = { status: \"rejected\", reason })\n                    .then(() => --remaining || resolve(results)));\n            });\n        });\n    if (NativePromise.any && typeof AggregateError !== 'undefined')\n        setProp(DexiePromise, \"any\", function () {\n            const possiblePromises = getArrayOf.apply(null, arguments).map(onPossibleParallellAsync);\n            return new DexiePromise((resolve, reject) => {\n                if (possiblePromises.length === 0)\n                    reject(new AggregateError([]));\n                let remaining = possiblePromises.length;\n                const failures = new Array(remaining);\n                possiblePromises.forEach((p, i) => DexiePromise.resolve(p).then(value => resolve(value), failure => {\n                    failures[i] = failure;\n                    if (!--remaining)\n                        reject(new AggregateError(failures));\n                }));\n            });\n        });\n}\nfunction executePromiseTask(promise, fn) {\n    try {\n        fn(value => {\n            if (promise._state !== null)\n                return;\n            if (value === promise)\n                throw new TypeError('A promise cannot be resolved with itself.');\n            var shouldExecuteTick = promise._lib && beginMicroTickScope();\n            if (value && typeof value.then === 'function') {\n                executePromiseTask(promise, (resolve, reject) => {\n                    value instanceof DexiePromise ?\n                        value._then(resolve, reject) :\n                        value.then(resolve, reject);\n                });\n            }\n            else {\n                promise._state = true;\n                promise._value = value;\n                propagateAllListeners(promise);\n            }\n            if (shouldExecuteTick)\n                endMicroTickScope();\n        }, handleRejection.bind(null, promise));\n    }\n    catch (ex) {\n        handleRejection(promise, ex);\n    }\n}\nfunction handleRejection(promise, reason) {\n    rejectingErrors.push(reason);\n    if (promise._state !== null)\n        return;\n    var shouldExecuteTick = promise._lib && beginMicroTickScope();\n    reason = rejectionMapper(reason);\n    promise._state = false;\n    promise._value = reason;\n    debug && reason !== null && typeof reason === 'object' && !reason._promise && tryCatch(() => {\n        var origProp = getPropertyDescriptor(reason, \"stack\");\n        reason._promise = promise;\n        setProp(reason, \"stack\", {\n            get: () => stack_being_generated ?\n                origProp && (origProp.get ?\n                    origProp.get.apply(reason) :\n                    origProp.value) :\n                promise.stack\n        });\n    });\n    addPossiblyUnhandledError(promise);\n    propagateAllListeners(promise);\n    if (shouldExecuteTick)\n        endMicroTickScope();\n}\nfunction propagateAllListeners(promise) {\n    var listeners = promise._listeners;\n    promise._listeners = [];\n    for (var i = 0, len = listeners.length; i < len; ++i) {\n        propagateToListener(promise, listeners[i]);\n    }\n    var psd = promise._PSD;\n    --psd.ref || psd.finalize();\n    if (numScheduledCalls === 0) {\n        ++numScheduledCalls;\n        asap(() => {\n            if (--numScheduledCalls === 0)\n                finalizePhysicalTick();\n        }, []);\n    }\n}\nfunction propagateToListener(promise, listener) {\n    if (promise._state === null) {\n        promise._listeners.push(listener);\n        return;\n    }\n    var cb = promise._state ? listener.onFulfilled : listener.onRejected;\n    if (cb === null) {\n        return (promise._state ? listener.resolve : listener.reject)(promise._value);\n    }\n    ++listener.psd.ref;\n    ++numScheduledCalls;\n    asap(callListener, [cb, promise, listener]);\n}\nfunction callListener(cb, promise, listener) {\n    try {\n        currentFulfiller = promise;\n        var ret, value = promise._value;\n        if (promise._state) {\n            ret = cb(value);\n        }\n        else {\n            if (rejectingErrors.length)\n                rejectingErrors = [];\n            ret = cb(value);\n            if (rejectingErrors.indexOf(value) === -1)\n                markErrorAsHandled(promise);\n        }\n        listener.resolve(ret);\n    }\n    catch (e) {\n        listener.reject(e);\n    }\n    finally {\n        currentFulfiller = null;\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n        --listener.psd.ref || listener.psd.finalize();\n    }\n}\nfunction getStack(promise, stacks, limit) {\n    if (stacks.length === limit)\n        return stacks;\n    var stack = \"\";\n    if (promise._state === false) {\n        var failure = promise._value, errorName, message;\n        if (failure != null) {\n            errorName = failure.name || \"Error\";\n            message = failure.message || failure;\n            stack = prettyStack(failure, 0);\n        }\n        else {\n            errorName = failure;\n            message = \"\";\n        }\n        stacks.push(errorName + (message ? \": \" + message : \"\") + stack);\n    }\n    if (debug) {\n        stack = prettyStack(promise._stackHolder, 2);\n        if (stack && stacks.indexOf(stack) === -1)\n            stacks.push(stack);\n        if (promise._prev)\n            getStack(promise._prev, stacks, limit);\n    }\n    return stacks;\n}\nfunction linkToPreviousPromise(promise, prev) {\n    var numPrev = prev ? prev._numPrev + 1 : 0;\n    if (numPrev < LONG_STACKS_CLIP_LIMIT) {\n        promise._prev = prev;\n        promise._numPrev = numPrev;\n    }\n}\nfunction physicalTick() {\n    beginMicroTickScope() && endMicroTickScope();\n}\nfunction beginMicroTickScope() {\n    var wasRootExec = isOutsideMicroTick;\n    isOutsideMicroTick = false;\n    needsNewPhysicalTick = false;\n    return wasRootExec;\n}\nfunction endMicroTickScope() {\n    var callbacks, i, l;\n    do {\n        while (microtickQueue.length > 0) {\n            callbacks = microtickQueue;\n            microtickQueue = [];\n            l = callbacks.length;\n            for (i = 0; i < l; ++i) {\n                var item = callbacks[i];\n                item[0].apply(null, item[1]);\n            }\n        }\n    } while (microtickQueue.length > 0);\n    isOutsideMicroTick = true;\n    needsNewPhysicalTick = true;\n}\nfunction finalizePhysicalTick() {\n    var unhandledErrs = unhandledErrors;\n    unhandledErrors = [];\n    unhandledErrs.forEach(p => {\n        p._PSD.onunhandled.call(null, p._value, p);\n    });\n    var finalizers = tickFinalizers.slice(0);\n    var i = finalizers.length;\n    while (i)\n        finalizers[--i]();\n}\nfunction run_at_end_of_this_or_next_physical_tick(fn) {\n    function finalizer() {\n        fn();\n        tickFinalizers.splice(tickFinalizers.indexOf(finalizer), 1);\n    }\n    tickFinalizers.push(finalizer);\n    ++numScheduledCalls;\n    asap(() => {\n        if (--numScheduledCalls === 0)\n            finalizePhysicalTick();\n    }, []);\n}\nfunction addPossiblyUnhandledError(promise) {\n    if (!unhandledErrors.some(p => p._value === promise._value))\n        unhandledErrors.push(promise);\n}\nfunction markErrorAsHandled(promise) {\n    var i = unhandledErrors.length;\n    while (i)\n        if (unhandledErrors[--i]._value === promise._value) {\n            unhandledErrors.splice(i, 1);\n            return;\n        }\n}\nfunction PromiseReject(reason) {\n    return new DexiePromise(INTERNAL, false, reason);\n}\nfunction wrap(fn, errorCatcher) {\n    var psd = PSD;\n    return function () {\n        var wasRootExec = beginMicroTickScope(), outerScope = PSD;\n        try {\n            switchToZone(psd, true);\n            return fn.apply(this, arguments);\n        }\n        catch (e) {\n            errorCatcher && errorCatcher(e);\n        }\n        finally {\n            switchToZone(outerScope, false);\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    };\n}\nconst task = { awaits: 0, echoes: 0, id: 0 };\nvar taskCounter = 0;\nvar zoneStack = [];\nvar zoneEchoes = 0;\nvar totalEchoes = 0;\nvar zone_id_counter = 0;\nfunction newScope(fn, props, a1, a2) {\n    var parent = PSD, psd = Object.create(parent);\n    psd.parent = parent;\n    psd.ref = 0;\n    psd.global = false;\n    psd.id = ++zone_id_counter;\n    var globalEnv = globalPSD.env;\n    psd.env = patchGlobalPromise ? {\n        Promise: DexiePromise,\n        PromiseProp: { value: DexiePromise, configurable: true, writable: true },\n        all: DexiePromise.all,\n        race: DexiePromise.race,\n        allSettled: DexiePromise.allSettled,\n        any: DexiePromise.any,\n        resolve: DexiePromise.resolve,\n        reject: DexiePromise.reject,\n        nthen: getPatchedPromiseThen(globalEnv.nthen, psd),\n        gthen: getPatchedPromiseThen(globalEnv.gthen, psd)\n    } : {};\n    if (props)\n        extend(psd, props);\n    ++parent.ref;\n    psd.finalize = function () {\n        --this.parent.ref || this.parent.finalize();\n    };\n    var rv = usePSD(psd, fn, a1, a2);\n    if (psd.ref === 0)\n        psd.finalize();\n    return rv;\n}\nfunction incrementExpectedAwaits() {\n    if (!task.id)\n        task.id = ++taskCounter;\n    ++task.awaits;\n    task.echoes += ZONE_ECHO_LIMIT;\n    return task.id;\n}\nfunction decrementExpectedAwaits() {\n    if (!task.awaits)\n        return false;\n    if (--task.awaits === 0)\n        task.id = 0;\n    task.echoes = task.awaits * ZONE_ECHO_LIMIT;\n    return true;\n}\nif (('' + nativePromiseThen).indexOf('[native code]') === -1) {\n    incrementExpectedAwaits = decrementExpectedAwaits = nop;\n}\nfunction onPossibleParallellAsync(possiblePromise) {\n    if (task.echoes && possiblePromise && possiblePromise.constructor === NativePromise) {\n        incrementExpectedAwaits();\n        return possiblePromise.then(x => {\n            decrementExpectedAwaits();\n            return x;\n        }, e => {\n            decrementExpectedAwaits();\n            return rejection(e);\n        });\n    }\n    return possiblePromise;\n}\nfunction zoneEnterEcho(targetZone) {\n    ++totalEchoes;\n    if (!task.echoes || --task.echoes === 0) {\n        task.echoes = task.id = 0;\n    }\n    zoneStack.push(PSD);\n    switchToZone(targetZone, true);\n}\nfunction zoneLeaveEcho() {\n    var zone = zoneStack[zoneStack.length - 1];\n    zoneStack.pop();\n    switchToZone(zone, false);\n}\nfunction switchToZone(targetZone, bEnteringZone) {\n    var currentZone = PSD;\n    if (bEnteringZone ? task.echoes && (!zoneEchoes++ || targetZone !== PSD) : zoneEchoes && (!--zoneEchoes || targetZone !== PSD)) {\n        enqueueNativeMicroTask(bEnteringZone ? zoneEnterEcho.bind(null, targetZone) : zoneLeaveEcho);\n    }\n    if (targetZone === PSD)\n        return;\n    PSD = targetZone;\n    if (currentZone === globalPSD)\n        globalPSD.env = snapShot();\n    if (patchGlobalPromise) {\n        var GlobalPromise = globalPSD.env.Promise;\n        var targetEnv = targetZone.env;\n        nativePromiseProto.then = targetEnv.nthen;\n        GlobalPromise.prototype.then = targetEnv.gthen;\n        if (currentZone.global || targetZone.global) {\n            Object.defineProperty(_global, 'Promise', targetEnv.PromiseProp);\n            GlobalPromise.all = targetEnv.all;\n            GlobalPromise.race = targetEnv.race;\n            GlobalPromise.resolve = targetEnv.resolve;\n            GlobalPromise.reject = targetEnv.reject;\n            if (targetEnv.allSettled)\n                GlobalPromise.allSettled = targetEnv.allSettled;\n            if (targetEnv.any)\n                GlobalPromise.any = targetEnv.any;\n        }\n    }\n}\nfunction snapShot() {\n    var GlobalPromise = _global.Promise;\n    return patchGlobalPromise ? {\n        Promise: GlobalPromise,\n        PromiseProp: Object.getOwnPropertyDescriptor(_global, \"Promise\"),\n        all: GlobalPromise.all,\n        race: GlobalPromise.race,\n        allSettled: GlobalPromise.allSettled,\n        any: GlobalPromise.any,\n        resolve: GlobalPromise.resolve,\n        reject: GlobalPromise.reject,\n        nthen: nativePromiseProto.then,\n        gthen: GlobalPromise.prototype.then\n    } : {};\n}\nfunction usePSD(psd, fn, a1, a2, a3) {\n    var outerScope = PSD;\n    try {\n        switchToZone(psd, true);\n        return fn(a1, a2, a3);\n    }\n    finally {\n        switchToZone(outerScope, false);\n    }\n}\nfunction enqueueNativeMicroTask(job) {\n    nativePromiseThen.call(resolvedNativePromise, job);\n}\nfunction nativeAwaitCompatibleWrap(fn, zone, possibleAwait, cleanup) {\n    return typeof fn !== 'function' ? fn : function () {\n        var outerZone = PSD;\n        if (possibleAwait)\n            incrementExpectedAwaits();\n        switchToZone(zone, true);\n        try {\n            return fn.apply(this, arguments);\n        }\n        finally {\n            switchToZone(outerZone, false);\n            if (cleanup)\n                enqueueNativeMicroTask(decrementExpectedAwaits);\n        }\n    };\n}\nfunction getPatchedPromiseThen(origThen, zone) {\n    return function (onResolved, onRejected) {\n        return origThen.call(this, nativeAwaitCompatibleWrap(onResolved, zone), nativeAwaitCompatibleWrap(onRejected, zone));\n    };\n}\nconst UNHANDLEDREJECTION = \"unhandledrejection\";\nfunction globalError(err, promise) {\n    var rv;\n    try {\n        rv = promise.onuncatched(err);\n    }\n    catch (e) { }\n    if (rv !== false)\n        try {\n            var event, eventData = { promise: promise, reason: err };\n            if (_global.document && document.createEvent) {\n                event = document.createEvent('Event');\n                event.initEvent(UNHANDLEDREJECTION, true, true);\n                extend(event, eventData);\n            }\n            else if (_global.CustomEvent) {\n                event = new CustomEvent(UNHANDLEDREJECTION, { detail: eventData });\n                extend(event, eventData);\n            }\n            if (event && _global.dispatchEvent) {\n                dispatchEvent(event);\n                if (!_global.PromiseRejectionEvent && _global.onunhandledrejection)\n                    try {\n                        _global.onunhandledrejection(event);\n                    }\n                    catch (_) { }\n            }\n            if (debug && event && !event.defaultPrevented) {\n                console.warn(`Unhandled rejection: ${err.stack || err}`);\n            }\n        }\n        catch (e) { }\n}\nvar rejection = DexiePromise.reject;\n\nfunction tempTransaction(db, mode, storeNames, fn) {\n    if (!db.idbdb || (!db._state.openComplete && (!PSD.letThrough && !db._vip))) {\n        if (db._state.openComplete) {\n            return rejection(new exceptions.DatabaseClosed(db._state.dbOpenError));\n        }\n        if (!db._state.isBeingOpened) {\n            if (!db._options.autoOpen)\n                return rejection(new exceptions.DatabaseClosed());\n            db.open().catch(nop);\n        }\n        return db._state.dbReadyPromise.then(() => tempTransaction(db, mode, storeNames, fn));\n    }\n    else {\n        var trans = db._createTransaction(mode, storeNames, db._dbSchema);\n        try {\n            trans.create();\n        }\n        catch (ex) {\n            return rejection(ex);\n        }\n        return trans._promise(mode, (resolve, reject) => {\n            return newScope(() => {\n                PSD.trans = trans;\n                return fn(resolve, reject, trans);\n            });\n        }).then(result => {\n            return trans._completion.then(() => result);\n        });\n    }\n}\n\nconst DEXIE_VERSION = '3.2.0';\nconst maxString = String.fromCharCode(65535);\nconst minKey = -Infinity;\nconst INVALID_KEY_ARGUMENT = \"Invalid key provided. Keys must be of type string, number, Date or Array<string | number | Date>.\";\nconst STRING_EXPECTED = \"String expected.\";\nconst connections = [];\nconst isIEOrEdge = typeof navigator !== 'undefined' && /(MSIE|Trident|Edge)/.test(navigator.userAgent);\nconst hasIEDeleteObjectStoreBug = isIEOrEdge;\nconst hangsOnDeleteLargeKeyRange = isIEOrEdge;\nconst dexieStackFrameFilter = frame => !/(dexie\\.js|dexie\\.min\\.js)/.test(frame);\nconst DBNAMES_DB = '__dbnames';\nconst READONLY = 'readonly';\nconst READWRITE = 'readwrite';\n\nfunction combine(filter1, filter2) {\n    return filter1 ?\n        filter2 ?\n            function () { return filter1.apply(this, arguments) && filter2.apply(this, arguments); } :\n            filter1 :\n        filter2;\n}\n\nconst AnyRange = {\n    type: 3 ,\n    lower: -Infinity,\n    lowerOpen: false,\n    upper: [[]],\n    upperOpen: false\n};\n\nfunction workaroundForUndefinedPrimKey(keyPath) {\n    return typeof keyPath === \"string\" && !/\\./.test(keyPath)\n        ? (obj) => {\n            if (obj[keyPath] === undefined && (keyPath in obj)) {\n                obj = deepClone(obj);\n                delete obj[keyPath];\n            }\n            return obj;\n        }\n        : (obj) => obj;\n}\n\nclass Table {\n    _trans(mode, fn, writeLocked) {\n        const trans = this._tx || PSD.trans;\n        const tableName = this.name;\n        function checkTableInTransaction(resolve, reject, trans) {\n            if (!trans.schema[tableName])\n                throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n            return fn(trans.idbtrans, trans);\n        }\n        const wasRootExec = beginMicroTickScope();\n        try {\n            return trans && trans.db === this.db ?\n                trans === PSD.trans ?\n                    trans._promise(mode, checkTableInTransaction, writeLocked) :\n                    newScope(() => trans._promise(mode, checkTableInTransaction, writeLocked), { trans: trans, transless: PSD.transless || PSD }) :\n                tempTransaction(this.db, mode, [this.name], checkTableInTransaction);\n        }\n        finally {\n            if (wasRootExec)\n                endMicroTickScope();\n        }\n    }\n    get(keyOrCrit, cb) {\n        if (keyOrCrit && keyOrCrit.constructor === Object)\n            return this.where(keyOrCrit).first(cb);\n        return this._trans('readonly', (trans) => {\n            return this.core.get({ trans, key: keyOrCrit })\n                .then(res => this.hook.reading.fire(res));\n        }).then(cb);\n    }\n    where(indexOrCrit) {\n        if (typeof indexOrCrit === 'string')\n            return new this.db.WhereClause(this, indexOrCrit);\n        if (isArray(indexOrCrit))\n            return new this.db.WhereClause(this, `[${indexOrCrit.join('+')}]`);\n        const keyPaths = keys(indexOrCrit);\n        if (keyPaths.length === 1)\n            return this\n                .where(keyPaths[0])\n                .equals(indexOrCrit[keyPaths[0]]);\n        const compoundIndex = this.schema.indexes.concat(this.schema.primKey).filter(ix => ix.compound &&\n            keyPaths.every(keyPath => ix.keyPath.indexOf(keyPath) >= 0) &&\n            ix.keyPath.every(keyPath => keyPaths.indexOf(keyPath) >= 0))[0];\n        if (compoundIndex && this.db._maxKey !== maxString)\n            return this\n                .where(compoundIndex.name)\n                .equals(compoundIndex.keyPath.map(kp => indexOrCrit[kp]));\n        if (!compoundIndex && debug)\n            console.warn(`The query ${JSON.stringify(indexOrCrit)} on ${this.name} would benefit of a ` +\n                `compound index [${keyPaths.join('+')}]`);\n        const { idxByName } = this.schema;\n        const idb = this.db._deps.indexedDB;\n        function equals(a, b) {\n            try {\n                return idb.cmp(a, b) === 0;\n            }\n            catch (e) {\n                return false;\n            }\n        }\n        const [idx, filterFunction] = keyPaths.reduce(([prevIndex, prevFilterFn], keyPath) => {\n            const index = idxByName[keyPath];\n            const value = indexOrCrit[keyPath];\n            return [\n                prevIndex || index,\n                prevIndex || !index ?\n                    combine(prevFilterFn, index && index.multi ?\n                        x => {\n                            const prop = getByKeyPath(x, keyPath);\n                            return isArray(prop) && prop.some(item => equals(value, item));\n                        } : x => equals(value, getByKeyPath(x, keyPath)))\n                    : prevFilterFn\n            ];\n        }, [null, null]);\n        return idx ?\n            this.where(idx.name).equals(indexOrCrit[idx.keyPath])\n                .filter(filterFunction) :\n            compoundIndex ?\n                this.filter(filterFunction) :\n                this.where(keyPaths).equals('');\n    }\n    filter(filterFunction) {\n        return this.toCollection().and(filterFunction);\n    }\n    count(thenShortcut) {\n        return this.toCollection().count(thenShortcut);\n    }\n    offset(offset) {\n        return this.toCollection().offset(offset);\n    }\n    limit(numRows) {\n        return this.toCollection().limit(numRows);\n    }\n    each(callback) {\n        return this.toCollection().each(callback);\n    }\n    toArray(thenShortcut) {\n        return this.toCollection().toArray(thenShortcut);\n    }\n    toCollection() {\n        return new this.db.Collection(new this.db.WhereClause(this));\n    }\n    orderBy(index) {\n        return new this.db.Collection(new this.db.WhereClause(this, isArray(index) ?\n            `[${index.join('+')}]` :\n            index));\n    }\n    reverse() {\n        return this.toCollection().reverse();\n    }\n    mapToClass(constructor) {\n        this.schema.mappedClass = constructor;\n        const readHook = obj => {\n            if (!obj)\n                return obj;\n            const res = Object.create(constructor.prototype);\n            for (var m in obj)\n                if (hasOwn(obj, m))\n                    try {\n                        res[m] = obj[m];\n                    }\n                    catch (_) { }\n            return res;\n        };\n        if (this.schema.readHook) {\n            this.hook.reading.unsubscribe(this.schema.readHook);\n        }\n        this.schema.readHook = readHook;\n        this.hook(\"reading\", readHook);\n        return constructor;\n    }\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return this.mapToClass(Class);\n    }\n    add(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'add', keys: key != null ? [key] : null, values: [objToAdd] });\n        }).then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    update(keyOrObject, modifications) {\n        if (typeof keyOrObject === 'object' && !isArray(keyOrObject)) {\n            const key = getByKeyPath(keyOrObject, this.schema.primKey.keyPath);\n            if (key === undefined)\n                return rejection(new exceptions.InvalidArgument(\"Given object does not contain its primary key\"));\n            try {\n                if (typeof modifications !== \"function\") {\n                    keys(modifications).forEach(keyPath => {\n                        setByKeyPath(keyOrObject, keyPath, modifications[keyPath]);\n                    });\n                }\n                else {\n                    modifications(keyOrObject, { value: keyOrObject, primKey: key });\n                }\n            }\n            catch (_a) {\n            }\n            return this.where(\":id\").equals(key).modify(modifications);\n        }\n        else {\n            return this.where(\":id\").equals(keyOrObject).modify(modifications);\n        }\n    }\n    put(obj, key) {\n        const { auto, keyPath } = this.schema.primKey;\n        let objToAdd = obj;\n        if (keyPath && auto) {\n            objToAdd = workaroundForUndefinedPrimKey(keyPath)(obj);\n        }\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'put', values: [objToAdd], keys: key != null ? [key] : null }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : res.lastResult)\n            .then(lastResult => {\n            if (keyPath) {\n                try {\n                    setByKeyPath(obj, keyPath, lastResult);\n                }\n                catch (_) { }\n            }\n            return lastResult;\n        });\n    }\n    delete(key) {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'delete', keys: [key] }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    clear() {\n        return this._trans('readwrite', trans => this.core.mutate({ trans, type: 'deleteRange', range: AnyRange }))\n            .then(res => res.numFailures ? DexiePromise.reject(res.failures[0]) : undefined);\n    }\n    bulkGet(keys) {\n        return this._trans('readonly', trans => {\n            return this.core.getMany({\n                keys,\n                trans\n            }).then(result => result.map(res => this.hook.reading.fire(res)));\n        });\n    }\n    bulkAdd(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkAdd(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToAdd = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'add', keys: keys, values: objectsToAdd, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkAdd(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkPut(objects, keysOrOptions, options) {\n        const keys = Array.isArray(keysOrOptions) ? keysOrOptions : undefined;\n        options = options || (keys ? undefined : keysOrOptions);\n        const wantResults = options ? options.allKeys : undefined;\n        return this._trans('readwrite', trans => {\n            const { auto, keyPath } = this.schema.primKey;\n            if (keyPath && keys)\n                throw new exceptions.InvalidArgument(\"bulkPut(): keys argument invalid on tables with inbound keys\");\n            if (keys && keys.length !== objects.length)\n                throw new exceptions.InvalidArgument(\"Arguments objects and keys must have the same length\");\n            const numObjects = objects.length;\n            let objectsToPut = keyPath && auto ?\n                objects.map(workaroundForUndefinedPrimKey(keyPath)) :\n                objects;\n            return this.core.mutate({ trans, type: 'put', keys: keys, values: objectsToPut, wantResults })\n                .then(({ numFailures, results, lastResult, failures }) => {\n                const result = wantResults ? results : lastResult;\n                if (numFailures === 0)\n                    return result;\n                throw new BulkError(`${this.name}.bulkPut(): ${numFailures} of ${numObjects} operations failed`, failures);\n            });\n        });\n    }\n    bulkDelete(keys) {\n        const numKeys = keys.length;\n        return this._trans('readwrite', trans => {\n            return this.core.mutate({ trans, type: 'delete', keys: keys });\n        }).then(({ numFailures, lastResult, failures }) => {\n            if (numFailures === 0)\n                return lastResult;\n            throw new BulkError(`${this.name}.bulkDelete(): ${numFailures} of ${numKeys} operations failed`, failures);\n        });\n    }\n}\n\nfunction Events(ctx) {\n    var evs = {};\n    var rv = function (eventName, subscriber) {\n        if (subscriber) {\n            var i = arguments.length, args = new Array(i - 1);\n            while (--i)\n                args[i - 1] = arguments[i];\n            evs[eventName].subscribe.apply(null, args);\n            return ctx;\n        }\n        else if (typeof (eventName) === 'string') {\n            return evs[eventName];\n        }\n    };\n    rv.addEventType = add;\n    for (var i = 1, l = arguments.length; i < l; ++i) {\n        add(arguments[i]);\n    }\n    return rv;\n    function add(eventName, chainFunction, defaultFunction) {\n        if (typeof eventName === 'object')\n            return addConfiguredEvents(eventName);\n        if (!chainFunction)\n            chainFunction = reverseStoppableEventChain;\n        if (!defaultFunction)\n            defaultFunction = nop;\n        var context = {\n            subscribers: [],\n            fire: defaultFunction,\n            subscribe: function (cb) {\n                if (context.subscribers.indexOf(cb) === -1) {\n                    context.subscribers.push(cb);\n                    context.fire = chainFunction(context.fire, cb);\n                }\n            },\n            unsubscribe: function (cb) {\n                context.subscribers = context.subscribers.filter(function (fn) { return fn !== cb; });\n                context.fire = context.subscribers.reduce(chainFunction, defaultFunction);\n            }\n        };\n        evs[eventName] = rv[eventName] = context;\n        return context;\n    }\n    function addConfiguredEvents(cfg) {\n        keys(cfg).forEach(function (eventName) {\n            var args = cfg[eventName];\n            if (isArray(args)) {\n                add(eventName, cfg[eventName][0], cfg[eventName][1]);\n            }\n            else if (args === 'asap') {\n                var context = add(eventName, mirror, function fire() {\n                    var i = arguments.length, args = new Array(i);\n                    while (i--)\n                        args[i] = arguments[i];\n                    context.subscribers.forEach(function (fn) {\n                        asap$1(function fireEvent() {\n                            fn.apply(null, args);\n                        });\n                    });\n                });\n            }\n            else\n                throw new exceptions.InvalidArgument(\"Invalid event config\");\n        });\n    }\n}\n\nfunction makeClassConstructor(prototype, constructor) {\n    derive(constructor).from({ prototype });\n    return constructor;\n}\n\nfunction createTableConstructor(db) {\n    return makeClassConstructor(Table.prototype, function Table(name, tableSchema, trans) {\n        this.db = db;\n        this._tx = trans;\n        this.name = name;\n        this.schema = tableSchema;\n        this.hook = db._allTables[name] ? db._allTables[name].hook : Events(null, {\n            \"creating\": [hookCreatingChain, nop],\n            \"reading\": [pureFunctionChain, mirror],\n            \"updating\": [hookUpdatingChain, nop],\n            \"deleting\": [hookDeletingChain, nop]\n        });\n    });\n}\n\nfunction isPlainKeyRange(ctx, ignoreLimitFilter) {\n    return !(ctx.filter || ctx.algorithm || ctx.or) &&\n        (ignoreLimitFilter ? ctx.justLimit : !ctx.replayFilter);\n}\nfunction addFilter(ctx, fn) {\n    ctx.filter = combine(ctx.filter, fn);\n}\nfunction addReplayFilter(ctx, factory, isLimitFilter) {\n    var curr = ctx.replayFilter;\n    ctx.replayFilter = curr ? () => combine(curr(), factory()) : factory;\n    ctx.justLimit = isLimitFilter && !curr;\n}\nfunction addMatchFilter(ctx, fn) {\n    ctx.isMatch = combine(ctx.isMatch, fn);\n}\nfunction getIndexOrStore(ctx, coreSchema) {\n    if (ctx.isPrimKey)\n        return coreSchema.primaryKey;\n    const index = coreSchema.getIndexByKeyPath(ctx.index);\n    if (!index)\n        throw new exceptions.Schema(\"KeyPath \" + ctx.index + \" on object store \" + coreSchema.name + \" is not indexed\");\n    return index;\n}\nfunction openCursor(ctx, coreTable, trans) {\n    const index = getIndexOrStore(ctx, coreTable.schema);\n    return coreTable.openCursor({\n        trans,\n        values: !ctx.keysOnly,\n        reverse: ctx.dir === 'prev',\n        unique: !!ctx.unique,\n        query: {\n            index,\n            range: ctx.range\n        }\n    });\n}\nfunction iter(ctx, fn, coreTrans, coreTable) {\n    const filter = ctx.replayFilter ? combine(ctx.filter, ctx.replayFilter()) : ctx.filter;\n    if (!ctx.or) {\n        return iterate(openCursor(ctx, coreTable, coreTrans), combine(ctx.algorithm, filter), fn, !ctx.keysOnly && ctx.valueMapper);\n    }\n    else {\n        const set = {};\n        const union = (item, cursor, advance) => {\n            if (!filter || filter(cursor, advance, result => cursor.stop(result), err => cursor.fail(err))) {\n                var primaryKey = cursor.primaryKey;\n                var key = '' + primaryKey;\n                if (key === '[object ArrayBuffer]')\n                    key = '' + new Uint8Array(primaryKey);\n                if (!hasOwn(set, key)) {\n                    set[key] = true;\n                    fn(item, cursor, advance);\n                }\n            }\n        };\n        return Promise.all([\n            ctx.or._iterate(union, coreTrans),\n            iterate(openCursor(ctx, coreTable, coreTrans), ctx.algorithm, union, !ctx.keysOnly && ctx.valueMapper)\n        ]);\n    }\n}\nfunction iterate(cursorPromise, filter, fn, valueMapper) {\n    var mappedFn = valueMapper ? (x, c, a) => fn(valueMapper(x), c, a) : fn;\n    var wrappedFn = wrap(mappedFn);\n    return cursorPromise.then(cursor => {\n        if (cursor) {\n            return cursor.start(() => {\n                var c = () => cursor.continue();\n                if (!filter || filter(cursor, advancer => c = advancer, val => { cursor.stop(val); c = nop; }, e => { cursor.fail(e); c = nop; }))\n                    wrappedFn(cursor.value, cursor, advancer => c = advancer);\n                c();\n            });\n        }\n    });\n}\n\nfunction cmp(a, b) {\n    try {\n        const ta = type(a);\n        const tb = type(b);\n        if (ta !== tb) {\n            if (ta === 'Array')\n                return 1;\n            if (tb === 'Array')\n                return -1;\n            if (ta === 'binary')\n                return 1;\n            if (tb === 'binary')\n                return -1;\n            if (ta === 'string')\n                return 1;\n            if (tb === 'string')\n                return -1;\n            if (ta === 'Date')\n                return 1;\n            if (tb !== 'Date')\n                return NaN;\n            return -1;\n        }\n        switch (ta) {\n            case 'number':\n            case 'Date':\n            case 'string':\n                return a > b ? 1 : a < b ? -1 : 0;\n            case 'binary': {\n                return compareUint8Arrays(getUint8Array(a), getUint8Array(b));\n            }\n            case 'Array':\n                return compareArrays(a, b);\n        }\n    }\n    catch (_a) { }\n    return NaN;\n}\nfunction compareArrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        const res = cmp(a[i], b[i]);\n        if (res !== 0)\n            return res;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction compareUint8Arrays(a, b) {\n    const al = a.length;\n    const bl = b.length;\n    const l = al < bl ? al : bl;\n    for (let i = 0; i < l; ++i) {\n        if (a[i] !== b[i])\n            return a[i] < b[i] ? -1 : 1;\n    }\n    return al === bl ? 0 : al < bl ? -1 : 1;\n}\nfunction type(x) {\n    const t = typeof x;\n    if (t !== 'object')\n        return t;\n    if (ArrayBuffer.isView(x))\n        return 'binary';\n    const tsTag = toStringTag(x);\n    return tsTag === 'ArrayBuffer' ? 'binary' : tsTag;\n}\nfunction getUint8Array(a) {\n    if (a instanceof Uint8Array)\n        return a;\n    if (ArrayBuffer.isView(a))\n        return new Uint8Array(a.buffer, a.byteOffset, a.byteLength);\n    return new Uint8Array(a);\n}\n\nclass Collection {\n    _read(fn, cb) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readonly', fn).then(cb);\n    }\n    _write(fn) {\n        var ctx = this._ctx;\n        return ctx.error ?\n            ctx.table._trans(null, rejection.bind(null, ctx.error)) :\n            ctx.table._trans('readwrite', fn, \"locked\");\n    }\n    _addAlgorithm(fn) {\n        var ctx = this._ctx;\n        ctx.algorithm = combine(ctx.algorithm, fn);\n    }\n    _iterate(fn, coreTrans) {\n        return iter(this._ctx, fn, coreTrans, this._ctx.table.core);\n    }\n    clone(props) {\n        var rv = Object.create(this.constructor.prototype), ctx = Object.create(this._ctx);\n        if (props)\n            extend(ctx, props);\n        rv._ctx = ctx;\n        return rv;\n    }\n    raw() {\n        this._ctx.valueMapper = null;\n        return this;\n    }\n    each(fn) {\n        var ctx = this._ctx;\n        return this._read(trans => iter(ctx, fn, trans, ctx.table.core));\n    }\n    count(cb) {\n        return this._read(trans => {\n            const ctx = this._ctx;\n            const coreTable = ctx.table.core;\n            if (isPlainKeyRange(ctx, true)) {\n                return coreTable.count({\n                    trans,\n                    query: {\n                        index: getIndexOrStore(ctx, coreTable.schema),\n                        range: ctx.range\n                    }\n                }).then(count => Math.min(count, ctx.limit));\n            }\n            else {\n                var count = 0;\n                return iter(ctx, () => { ++count; return false; }, trans, coreTable)\n                    .then(() => count);\n            }\n        }).then(cb);\n    }\n    sortBy(keyPath, cb) {\n        const parts = keyPath.split('.').reverse(), lastPart = parts[0], lastIndex = parts.length - 1;\n        function getval(obj, i) {\n            if (i)\n                return getval(obj[parts[i]], i - 1);\n            return obj[lastPart];\n        }\n        var order = this._ctx.dir === \"next\" ? 1 : -1;\n        function sorter(a, b) {\n            var aVal = getval(a, lastIndex), bVal = getval(b, lastIndex);\n            return aVal < bVal ? -order : aVal > bVal ? order : 0;\n        }\n        return this.toArray(function (a) {\n            return a.sort(sorter);\n        }).then(cb);\n    }\n    toArray(cb) {\n        return this._read(trans => {\n            var ctx = this._ctx;\n            if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n                const { valueMapper } = ctx;\n                const index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    limit: ctx.limit,\n                    values: true,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                }).then(({ result }) => valueMapper ? result.map(valueMapper) : result);\n            }\n            else {\n                const a = [];\n                return iter(ctx, item => a.push(item), trans, ctx.table.core).then(() => a);\n            }\n        }, cb);\n    }\n    offset(offset) {\n        var ctx = this._ctx;\n        if (offset <= 0)\n            return this;\n        ctx.offset += offset;\n        if (isPlainKeyRange(ctx)) {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return (cursor, advance) => {\n                    if (offsetLeft === 0)\n                        return true;\n                    if (offsetLeft === 1) {\n                        --offsetLeft;\n                        return false;\n                    }\n                    advance(() => {\n                        cursor.advance(offsetLeft);\n                        offsetLeft = 0;\n                    });\n                    return false;\n                };\n            });\n        }\n        else {\n            addReplayFilter(ctx, () => {\n                var offsetLeft = offset;\n                return () => (--offsetLeft < 0);\n            });\n        }\n        return this;\n    }\n    limit(numRows) {\n        this._ctx.limit = Math.min(this._ctx.limit, numRows);\n        addReplayFilter(this._ctx, () => {\n            var rowsLeft = numRows;\n            return function (cursor, advance, resolve) {\n                if (--rowsLeft <= 0)\n                    advance(resolve);\n                return rowsLeft >= 0;\n            };\n        }, true);\n        return this;\n    }\n    until(filterFunction, bIncludeStopEntry) {\n        addFilter(this._ctx, function (cursor, advance, resolve) {\n            if (filterFunction(cursor.value)) {\n                advance(resolve);\n                return bIncludeStopEntry;\n            }\n            else {\n                return true;\n            }\n        });\n        return this;\n    }\n    first(cb) {\n        return this.limit(1).toArray(function (a) { return a[0]; }).then(cb);\n    }\n    last(cb) {\n        return this.reverse().first(cb);\n    }\n    filter(filterFunction) {\n        addFilter(this._ctx, function (cursor) {\n            return filterFunction(cursor.value);\n        });\n        addMatchFilter(this._ctx, filterFunction);\n        return this;\n    }\n    and(filter) {\n        return this.filter(filter);\n    }\n    or(indexName) {\n        return new this.db.WhereClause(this._ctx.table, indexName, this);\n    }\n    reverse() {\n        this._ctx.dir = (this._ctx.dir === \"prev\" ? \"next\" : \"prev\");\n        if (this._ondirectionchange)\n            this._ondirectionchange(this._ctx.dir);\n        return this;\n    }\n    desc() {\n        return this.reverse();\n    }\n    eachKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.key, cursor); });\n    }\n    eachUniqueKey(cb) {\n        this._ctx.unique = \"unique\";\n        return this.eachKey(cb);\n    }\n    eachPrimaryKey(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        return this.each(function (val, cursor) { cb(cursor.primaryKey, cursor); });\n    }\n    keys(cb) {\n        var ctx = this._ctx;\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.key);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    primaryKeys(cb) {\n        var ctx = this._ctx;\n        if (ctx.dir === 'next' && isPlainKeyRange(ctx, true) && ctx.limit > 0) {\n            return this._read(trans => {\n                var index = getIndexOrStore(ctx, ctx.table.core.schema);\n                return ctx.table.core.query({\n                    trans,\n                    values: false,\n                    limit: ctx.limit,\n                    query: {\n                        index,\n                        range: ctx.range\n                    }\n                });\n            }).then(({ result }) => result).then(cb);\n        }\n        ctx.keysOnly = !ctx.isMatch;\n        var a = [];\n        return this.each(function (item, cursor) {\n            a.push(cursor.primaryKey);\n        }).then(function () {\n            return a;\n        }).then(cb);\n    }\n    uniqueKeys(cb) {\n        this._ctx.unique = \"unique\";\n        return this.keys(cb);\n    }\n    firstKey(cb) {\n        return this.limit(1).keys(function (a) { return a[0]; }).then(cb);\n    }\n    lastKey(cb) {\n        return this.reverse().firstKey(cb);\n    }\n    distinct() {\n        var ctx = this._ctx, idx = ctx.index && ctx.table.schema.idxByName[ctx.index];\n        if (!idx || !idx.multi)\n            return this;\n        var set = {};\n        addFilter(this._ctx, function (cursor) {\n            var strKey = cursor.primaryKey.toString();\n            var found = hasOwn(set, strKey);\n            set[strKey] = true;\n            return !found;\n        });\n        return this;\n    }\n    modify(changes) {\n        var ctx = this._ctx;\n        return this._write(trans => {\n            var modifyer;\n            if (typeof changes === 'function') {\n                modifyer = changes;\n            }\n            else {\n                var keyPaths = keys(changes);\n                var numKeys = keyPaths.length;\n                modifyer = function (item) {\n                    var anythingModified = false;\n                    for (var i = 0; i < numKeys; ++i) {\n                        var keyPath = keyPaths[i], val = changes[keyPath];\n                        if (getByKeyPath(item, keyPath) !== val) {\n                            setByKeyPath(item, keyPath, val);\n                            anythingModified = true;\n                        }\n                    }\n                    return anythingModified;\n                };\n            }\n            const coreTable = ctx.table.core;\n            const { outbound, extractKey } = coreTable.schema.primaryKey;\n            const limit = this.db._options.modifyChunkSize || 200;\n            const totalFailures = [];\n            let successCount = 0;\n            const failedKeys = [];\n            const applyMutateResult = (expectedCount, res) => {\n                const { failures, numFailures } = res;\n                successCount += expectedCount - numFailures;\n                for (let pos of keys(failures)) {\n                    totalFailures.push(failures[pos]);\n                }\n            };\n            return this.clone().primaryKeys().then(keys => {\n                const nextChunk = (offset) => {\n                    const count = Math.min(limit, keys.length - offset);\n                    return coreTable.getMany({\n                        trans,\n                        keys: keys.slice(offset, offset + count),\n                        cache: \"immutable\"\n                    }).then(values => {\n                        const addValues = [];\n                        const putValues = [];\n                        const putKeys = outbound ? [] : null;\n                        const deleteKeys = [];\n                        for (let i = 0; i < count; ++i) {\n                            const origValue = values[i];\n                            const ctx = {\n                                value: deepClone(origValue),\n                                primKey: keys[offset + i]\n                            };\n                            if (modifyer.call(ctx, ctx.value, ctx) !== false) {\n                                if (ctx.value == null) {\n                                    deleteKeys.push(keys[offset + i]);\n                                }\n                                else if (!outbound && cmp(extractKey(origValue), extractKey(ctx.value)) !== 0) {\n                                    deleteKeys.push(keys[offset + i]);\n                                    addValues.push(ctx.value);\n                                }\n                                else {\n                                    putValues.push(ctx.value);\n                                    if (outbound)\n                                        putKeys.push(keys[offset + i]);\n                                }\n                            }\n                        }\n                        const criteria = isPlainKeyRange(ctx) &&\n                            ctx.limit === Infinity &&\n                            (typeof changes !== 'function' || changes === deleteCallback) && {\n                            index: ctx.index,\n                            range: ctx.range\n                        };\n                        return Promise.resolve(addValues.length > 0 &&\n                            coreTable.mutate({ trans, type: 'add', values: addValues })\n                                .then(res => {\n                                for (let pos in res.failures) {\n                                    deleteKeys.splice(parseInt(pos), 1);\n                                }\n                                applyMutateResult(addValues.length, res);\n                            })).then(() => (putValues.length > 0 || (criteria && typeof changes === 'object')) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'put',\n                                keys: putKeys,\n                                values: putValues,\n                                criteria,\n                                changeSpec: typeof changes !== 'function'\n                                    && changes\n                            }).then(res => applyMutateResult(putValues.length, res))).then(() => (deleteKeys.length > 0 || (criteria && changes === deleteCallback)) &&\n                            coreTable.mutate({\n                                trans,\n                                type: 'delete',\n                                keys: deleteKeys,\n                                criteria\n                            }).then(res => applyMutateResult(deleteKeys.length, res))).then(() => {\n                            return keys.length > offset + count && nextChunk(offset + limit);\n                        });\n                    });\n                };\n                return nextChunk(0).then(() => {\n                    if (totalFailures.length > 0)\n                        throw new ModifyError(\"Error modifying one or more objects\", totalFailures, successCount, failedKeys);\n                    return keys.length;\n                });\n            });\n        });\n    }\n    delete() {\n        var ctx = this._ctx, range = ctx.range;\n        if (isPlainKeyRange(ctx) &&\n            ((ctx.isPrimKey && !hangsOnDeleteLargeKeyRange) || range.type === 3 ))\n         {\n            return this._write(trans => {\n                const { primaryKey } = ctx.table.core.schema;\n                const coreRange = range;\n                return ctx.table.core.count({ trans, query: { index: primaryKey, range: coreRange } }).then(count => {\n                    return ctx.table.core.mutate({ trans, type: 'deleteRange', range: coreRange })\n                        .then(({ failures, lastResult, results, numFailures }) => {\n                        if (numFailures)\n                            throw new ModifyError(\"Could not delete some values\", Object.keys(failures).map(pos => failures[pos]), count - numFailures);\n                        return count - numFailures;\n                    });\n                });\n            });\n        }\n        return this.modify(deleteCallback);\n    }\n}\nconst deleteCallback = (value, ctx) => ctx.value = null;\n\nfunction createCollectionConstructor(db) {\n    return makeClassConstructor(Collection.prototype, function Collection(whereClause, keyRangeGenerator) {\n        this.db = db;\n        let keyRange = AnyRange, error = null;\n        if (keyRangeGenerator)\n            try {\n                keyRange = keyRangeGenerator();\n            }\n            catch (ex) {\n                error = ex;\n            }\n        const whereCtx = whereClause._ctx;\n        const table = whereCtx.table;\n        const readingHook = table.hook.reading.fire;\n        this._ctx = {\n            table: table,\n            index: whereCtx.index,\n            isPrimKey: (!whereCtx.index || (table.schema.primKey.keyPath && whereCtx.index === table.schema.primKey.name)),\n            range: keyRange,\n            keysOnly: false,\n            dir: \"next\",\n            unique: \"\",\n            algorithm: null,\n            filter: null,\n            replayFilter: null,\n            justLimit: true,\n            isMatch: null,\n            offset: 0,\n            limit: Infinity,\n            error: error,\n            or: whereCtx.or,\n            valueMapper: readingHook !== mirror ? readingHook : null\n        };\n    });\n}\n\nfunction simpleCompare(a, b) {\n    return a < b ? -1 : a === b ? 0 : 1;\n}\nfunction simpleCompareReverse(a, b) {\n    return a > b ? -1 : a === b ? 0 : 1;\n}\n\nfunction fail(collectionOrWhereClause, err, T) {\n    var collection = collectionOrWhereClause instanceof WhereClause ?\n        new collectionOrWhereClause.Collection(collectionOrWhereClause) :\n        collectionOrWhereClause;\n    collection._ctx.error = T ? new T(err) : new TypeError(err);\n    return collection;\n}\nfunction emptyCollection(whereClause) {\n    return new whereClause.Collection(whereClause, () => rangeEqual(\"\")).limit(0);\n}\nfunction upperFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toUpperCase() :\n        (s) => s.toLowerCase();\n}\nfunction lowerFactory(dir) {\n    return dir === \"next\" ?\n        (s) => s.toLowerCase() :\n        (s) => s.toUpperCase();\n}\nfunction nextCasing(key, lowerKey, upperNeedle, lowerNeedle, cmp, dir) {\n    var length = Math.min(key.length, lowerNeedle.length);\n    var llp = -1;\n    for (var i = 0; i < length; ++i) {\n        var lwrKeyChar = lowerKey[i];\n        if (lwrKeyChar !== lowerNeedle[i]) {\n            if (cmp(key[i], upperNeedle[i]) < 0)\n                return key.substr(0, i) + upperNeedle[i] + upperNeedle.substr(i + 1);\n            if (cmp(key[i], lowerNeedle[i]) < 0)\n                return key.substr(0, i) + lowerNeedle[i] + upperNeedle.substr(i + 1);\n            if (llp >= 0)\n                return key.substr(0, llp) + lowerKey[llp] + upperNeedle.substr(llp + 1);\n            return null;\n        }\n        if (cmp(key[i], lwrKeyChar) < 0)\n            llp = i;\n    }\n    if (length < lowerNeedle.length && dir === \"next\")\n        return key + upperNeedle.substr(key.length);\n    if (length < key.length && dir === \"prev\")\n        return key.substr(0, upperNeedle.length);\n    return (llp < 0 ? null : key.substr(0, llp) + lowerNeedle[llp] + upperNeedle.substr(llp + 1));\n}\nfunction addIgnoreCaseAlgorithm(whereClause, match, needles, suffix) {\n    var upper, lower, compare, upperNeedles, lowerNeedles, direction, nextKeySuffix, needlesLen = needles.length;\n    if (!needles.every(s => typeof s === 'string')) {\n        return fail(whereClause, STRING_EXPECTED);\n    }\n    function initDirection(dir) {\n        upper = upperFactory(dir);\n        lower = lowerFactory(dir);\n        compare = (dir === \"next\" ? simpleCompare : simpleCompareReverse);\n        var needleBounds = needles.map(function (needle) {\n            return { lower: lower(needle), upper: upper(needle) };\n        }).sort(function (a, b) {\n            return compare(a.lower, b.lower);\n        });\n        upperNeedles = needleBounds.map(function (nb) { return nb.upper; });\n        lowerNeedles = needleBounds.map(function (nb) { return nb.lower; });\n        direction = dir;\n        nextKeySuffix = (dir === \"next\" ? \"\" : suffix);\n    }\n    initDirection(\"next\");\n    var c = new whereClause.Collection(whereClause, () => createRange(upperNeedles[0], lowerNeedles[needlesLen - 1] + suffix));\n    c._ondirectionchange = function (direction) {\n        initDirection(direction);\n    };\n    var firstPossibleNeedle = 0;\n    c._addAlgorithm(function (cursor, advance, resolve) {\n        var key = cursor.key;\n        if (typeof key !== 'string')\n            return false;\n        var lowerKey = lower(key);\n        if (match(lowerKey, lowerNeedles, firstPossibleNeedle)) {\n            return true;\n        }\n        else {\n            var lowestPossibleCasing = null;\n            for (var i = firstPossibleNeedle; i < needlesLen; ++i) {\n                var casing = nextCasing(key, lowerKey, upperNeedles[i], lowerNeedles[i], compare, direction);\n                if (casing === null && lowestPossibleCasing === null)\n                    firstPossibleNeedle = i + 1;\n                else if (lowestPossibleCasing === null || compare(lowestPossibleCasing, casing) > 0) {\n                    lowestPossibleCasing = casing;\n                }\n            }\n            if (lowestPossibleCasing !== null) {\n                advance(function () { cursor.continue(lowestPossibleCasing + nextKeySuffix); });\n            }\n            else {\n                advance(resolve);\n            }\n            return false;\n        }\n    });\n    return c;\n}\nfunction createRange(lower, upper, lowerOpen, upperOpen) {\n    return {\n        type: 2 ,\n        lower,\n        upper,\n        lowerOpen,\n        upperOpen\n    };\n}\nfunction rangeEqual(value) {\n    return {\n        type: 1 ,\n        lower: value,\n        upper: value\n    };\n}\n\nclass WhereClause {\n    get Collection() {\n        return this._ctx.table.db.Collection;\n    }\n    between(lower, upper, includeLower, includeUpper) {\n        includeLower = includeLower !== false;\n        includeUpper = includeUpper === true;\n        try {\n            if ((this._cmp(lower, upper) > 0) ||\n                (this._cmp(lower, upper) === 0 && (includeLower || includeUpper) && !(includeLower && includeUpper)))\n                return emptyCollection(this);\n            return new this.Collection(this, () => createRange(lower, upper, !includeLower, !includeUpper));\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n    }\n    equals(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => rangeEqual(value));\n    }\n    above(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, true));\n    }\n    aboveOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(value, undefined, false));\n    }\n    below(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value, false, true));\n    }\n    belowOrEqual(value) {\n        if (value == null)\n            return fail(this, INVALID_KEY_ARGUMENT);\n        return new this.Collection(this, () => createRange(undefined, value));\n    }\n    startsWith(str) {\n        if (typeof str !== 'string')\n            return fail(this, STRING_EXPECTED);\n        return this.between(str, str + maxString, true, true);\n    }\n    startsWithIgnoreCase(str) {\n        if (str === \"\")\n            return this.startsWith(str);\n        return addIgnoreCaseAlgorithm(this, (x, a) => x.indexOf(a[0]) === 0, [str], maxString);\n    }\n    equalsIgnoreCase(str) {\n        return addIgnoreCaseAlgorithm(this, (x, a) => x === a[0], [str], \"\");\n    }\n    anyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.indexOf(x) !== -1, set, \"\");\n    }\n    startsWithAnyOfIgnoreCase() {\n        var set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return emptyCollection(this);\n        return addIgnoreCaseAlgorithm(this, (x, a) => a.some(n => x.indexOf(n) === 0), set, maxString);\n    }\n    anyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        let compare = this._cmp;\n        try {\n            set.sort(compare);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        const c = new this.Collection(this, () => createRange(set[0], set[set.length - 1]));\n        c._ondirectionchange = direction => {\n            compare = (direction === \"next\" ?\n                this._ascending :\n                this._descending);\n            set.sort(compare);\n        };\n        let i = 0;\n        c._addAlgorithm((cursor, advance, resolve) => {\n            const key = cursor.key;\n            while (compare(key, set[i]) > 0) {\n                ++i;\n                if (i === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (compare(key, set[i]) === 0) {\n                return true;\n            }\n            else {\n                advance(() => { cursor.continue(set[i]); });\n                return false;\n            }\n        });\n        return c;\n    }\n    notEqual(value) {\n        return this.inAnyRange([[minKey, value], [value, this.db._maxKey]], { includeLowers: false, includeUppers: false });\n    }\n    noneOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (set.length === 0)\n            return new this.Collection(this);\n        try {\n            set.sort(this._ascending);\n        }\n        catch (e) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        const ranges = set.reduce((res, val) => res ?\n            res.concat([[res[res.length - 1][1], val]]) :\n            [[minKey, val]], null);\n        ranges.push([set[set.length - 1], this.db._maxKey]);\n        return this.inAnyRange(ranges, { includeLowers: false, includeUppers: false });\n    }\n    inAnyRange(ranges, options) {\n        const cmp = this._cmp, ascending = this._ascending, descending = this._descending, min = this._min, max = this._max;\n        if (ranges.length === 0)\n            return emptyCollection(this);\n        if (!ranges.every(range => range[0] !== undefined &&\n            range[1] !== undefined &&\n            ascending(range[0], range[1]) <= 0)) {\n            return fail(this, \"First argument to inAnyRange() must be an Array of two-value Arrays [lower,upper] where upper must not be lower than lower\", exceptions.InvalidArgument);\n        }\n        const includeLowers = !options || options.includeLowers !== false;\n        const includeUppers = options && options.includeUppers === true;\n        function addRange(ranges, newRange) {\n            let i = 0, l = ranges.length;\n            for (; i < l; ++i) {\n                const range = ranges[i];\n                if (cmp(newRange[0], range[1]) < 0 && cmp(newRange[1], range[0]) > 0) {\n                    range[0] = min(range[0], newRange[0]);\n                    range[1] = max(range[1], newRange[1]);\n                    break;\n                }\n            }\n            if (i === l)\n                ranges.push(newRange);\n            return ranges;\n        }\n        let sortDirection = ascending;\n        function rangeSorter(a, b) { return sortDirection(a[0], b[0]); }\n        let set;\n        try {\n            set = ranges.reduce(addRange, []);\n            set.sort(rangeSorter);\n        }\n        catch (ex) {\n            return fail(this, INVALID_KEY_ARGUMENT);\n        }\n        let rangePos = 0;\n        const keyIsBeyondCurrentEntry = includeUppers ?\n            key => ascending(key, set[rangePos][1]) > 0 :\n            key => ascending(key, set[rangePos][1]) >= 0;\n        const keyIsBeforeCurrentEntry = includeLowers ?\n            key => descending(key, set[rangePos][0]) > 0 :\n            key => descending(key, set[rangePos][0]) >= 0;\n        function keyWithinCurrentRange(key) {\n            return !keyIsBeyondCurrentEntry(key) && !keyIsBeforeCurrentEntry(key);\n        }\n        let checkKey = keyIsBeyondCurrentEntry;\n        const c = new this.Collection(this, () => createRange(set[0][0], set[set.length - 1][1], !includeLowers, !includeUppers));\n        c._ondirectionchange = direction => {\n            if (direction === \"next\") {\n                checkKey = keyIsBeyondCurrentEntry;\n                sortDirection = ascending;\n            }\n            else {\n                checkKey = keyIsBeforeCurrentEntry;\n                sortDirection = descending;\n            }\n            set.sort(rangeSorter);\n        };\n        c._addAlgorithm((cursor, advance, resolve) => {\n            var key = cursor.key;\n            while (checkKey(key)) {\n                ++rangePos;\n                if (rangePos === set.length) {\n                    advance(resolve);\n                    return false;\n                }\n            }\n            if (keyWithinCurrentRange(key)) {\n                return true;\n            }\n            else if (this._cmp(key, set[rangePos][1]) === 0 || this._cmp(key, set[rangePos][0]) === 0) {\n                return false;\n            }\n            else {\n                advance(() => {\n                    if (sortDirection === ascending)\n                        cursor.continue(set[rangePos][0]);\n                    else\n                        cursor.continue(set[rangePos][1]);\n                });\n                return false;\n            }\n        });\n        return c;\n    }\n    startsWithAnyOf() {\n        const set = getArrayOf.apply(NO_CHAR_ARRAY, arguments);\n        if (!set.every(s => typeof s === 'string')) {\n            return fail(this, \"startsWithAnyOf() only works with strings\");\n        }\n        if (set.length === 0)\n            return emptyCollection(this);\n        return this.inAnyRange(set.map((str) => [str, str + maxString]));\n    }\n}\n\nfunction createWhereClauseConstructor(db) {\n    return makeClassConstructor(WhereClause.prototype, function WhereClause(table, index, orCollection) {\n        this.db = db;\n        this._ctx = {\n            table: table,\n            index: index === \":id\" ? null : index,\n            or: orCollection\n        };\n        const indexedDB = db._deps.indexedDB;\n        if (!indexedDB)\n            throw new exceptions.MissingAPI();\n        this._cmp = this._ascending = indexedDB.cmp.bind(indexedDB);\n        this._descending = (a, b) => indexedDB.cmp(b, a);\n        this._max = (a, b) => indexedDB.cmp(a, b) > 0 ? a : b;\n        this._min = (a, b) => indexedDB.cmp(a, b) < 0 ? a : b;\n        this._IDBKeyRange = db._deps.IDBKeyRange;\n    });\n}\n\nfunction eventRejectHandler(reject) {\n    return wrap(function (event) {\n        preventDefault(event);\n        reject(event.target.error);\n        return false;\n    });\n}\nfunction preventDefault(event) {\n    if (event.stopPropagation)\n        event.stopPropagation();\n    if (event.preventDefault)\n        event.preventDefault();\n}\n\nconst DEXIE_STORAGE_MUTATED_EVENT_NAME = 'storagemutated';\nconst STORAGE_MUTATED_DOM_EVENT_NAME = 'x-storagemutated-1';\nconst globalEvents = Events(null, DEXIE_STORAGE_MUTATED_EVENT_NAME);\n\nclass Transaction {\n    _lock() {\n        assert(!PSD.global);\n        ++this._reculock;\n        if (this._reculock === 1 && !PSD.global)\n            PSD.lockOwnerFor = this;\n        return this;\n    }\n    _unlock() {\n        assert(!PSD.global);\n        if (--this._reculock === 0) {\n            if (!PSD.global)\n                PSD.lockOwnerFor = null;\n            while (this._blockedFuncs.length > 0 && !this._locked()) {\n                var fnAndPSD = this._blockedFuncs.shift();\n                try {\n                    usePSD(fnAndPSD[1], fnAndPSD[0]);\n                }\n                catch (e) { }\n            }\n        }\n        return this;\n    }\n    _locked() {\n        return this._reculock && PSD.lockOwnerFor !== this;\n    }\n    create(idbtrans) {\n        if (!this.mode)\n            return this;\n        const idbdb = this.db.idbdb;\n        const dbOpenError = this.db._state.dbOpenError;\n        assert(!this.idbtrans);\n        if (!idbtrans && !idbdb) {\n            switch (dbOpenError && dbOpenError.name) {\n                case \"DatabaseClosedError\":\n                    throw new exceptions.DatabaseClosed(dbOpenError);\n                case \"MissingAPIError\":\n                    throw new exceptions.MissingAPI(dbOpenError.message, dbOpenError);\n                default:\n                    throw new exceptions.OpenFailed(dbOpenError);\n            }\n        }\n        if (!this.active)\n            throw new exceptions.TransactionInactive();\n        assert(this._completion._state === null);\n        idbtrans = this.idbtrans = idbtrans ||\n            (this.db.core\n                ? this.db.core.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability })\n                : idbdb.transaction(this.storeNames, this.mode, { durability: this.chromeTransactionDurability }));\n        idbtrans.onerror = wrap(ev => {\n            preventDefault(ev);\n            this._reject(idbtrans.error);\n        });\n        idbtrans.onabort = wrap(ev => {\n            preventDefault(ev);\n            this.active && this._reject(new exceptions.Abort(idbtrans.error));\n            this.active = false;\n            this.on(\"abort\").fire(ev);\n        });\n        idbtrans.oncomplete = wrap(() => {\n            this.active = false;\n            this._resolve();\n            if ('mutatedParts' in idbtrans) {\n                globalEvents.storagemutated.fire(idbtrans[\"mutatedParts\"]);\n            }\n        });\n        return this;\n    }\n    _promise(mode, fn, bWriteLock) {\n        if (mode === 'readwrite' && this.mode !== 'readwrite')\n            return rejection(new exceptions.ReadOnly(\"Transaction is readonly\"));\n        if (!this.active)\n            return rejection(new exceptions.TransactionInactive());\n        if (this._locked()) {\n            return new DexiePromise((resolve, reject) => {\n                this._blockedFuncs.push([() => {\n                        this._promise(mode, fn, bWriteLock).then(resolve, reject);\n                    }, PSD]);\n            });\n        }\n        else if (bWriteLock) {\n            return newScope(() => {\n                var p = new DexiePromise((resolve, reject) => {\n                    this._lock();\n                    const rv = fn(resolve, reject, this);\n                    if (rv && rv.then)\n                        rv.then(resolve, reject);\n                });\n                p.finally(() => this._unlock());\n                p._lib = true;\n                return p;\n            });\n        }\n        else {\n            var p = new DexiePromise((resolve, reject) => {\n                var rv = fn(resolve, reject, this);\n                if (rv && rv.then)\n                    rv.then(resolve, reject);\n            });\n            p._lib = true;\n            return p;\n        }\n    }\n    _root() {\n        return this.parent ? this.parent._root() : this;\n    }\n    waitFor(promiseLike) {\n        var root = this._root();\n        const promise = DexiePromise.resolve(promiseLike);\n        if (root._waitingFor) {\n            root._waitingFor = root._waitingFor.then(() => promise);\n        }\n        else {\n            root._waitingFor = promise;\n            root._waitingQueue = [];\n            var store = root.idbtrans.objectStore(root.storeNames[0]);\n            (function spin() {\n                ++root._spinCount;\n                while (root._waitingQueue.length)\n                    (root._waitingQueue.shift())();\n                if (root._waitingFor)\n                    store.get(-Infinity).onsuccess = spin;\n            }());\n        }\n        var currentWaitPromise = root._waitingFor;\n        return new DexiePromise((resolve, reject) => {\n            promise.then(res => root._waitingQueue.push(wrap(resolve.bind(null, res))), err => root._waitingQueue.push(wrap(reject.bind(null, err)))).finally(() => {\n                if (root._waitingFor === currentWaitPromise) {\n                    root._waitingFor = null;\n                }\n            });\n        });\n    }\n    abort() {\n        if (this.active) {\n            this.active = false;\n            if (this.idbtrans)\n                this.idbtrans.abort();\n            this._reject(new exceptions.Abort());\n        }\n    }\n    table(tableName) {\n        const memoizedTables = (this._memoizedTables || (this._memoizedTables = {}));\n        if (hasOwn(memoizedTables, tableName))\n            return memoizedTables[tableName];\n        const tableSchema = this.schema[tableName];\n        if (!tableSchema) {\n            throw new exceptions.NotFound(\"Table \" + tableName + \" not part of transaction\");\n        }\n        const transactionBoundTable = new this.db.Table(tableName, tableSchema, this);\n        transactionBoundTable.core = this.db.core.table(tableName);\n        memoizedTables[tableName] = transactionBoundTable;\n        return transactionBoundTable;\n    }\n}\n\nfunction createTransactionConstructor(db) {\n    return makeClassConstructor(Transaction.prototype, function Transaction(mode, storeNames, dbschema, chromeTransactionDurability, parent) {\n        this.db = db;\n        this.mode = mode;\n        this.storeNames = storeNames;\n        this.schema = dbschema;\n        this.chromeTransactionDurability = chromeTransactionDurability;\n        this.idbtrans = null;\n        this.on = Events(this, \"complete\", \"error\", \"abort\");\n        this.parent = parent || null;\n        this.active = true;\n        this._reculock = 0;\n        this._blockedFuncs = [];\n        this._resolve = null;\n        this._reject = null;\n        this._waitingFor = null;\n        this._waitingQueue = null;\n        this._spinCount = 0;\n        this._completion = new DexiePromise((resolve, reject) => {\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        this._completion.then(() => {\n            this.active = false;\n            this.on.complete.fire();\n        }, e => {\n            var wasActive = this.active;\n            this.active = false;\n            this.on.error.fire(e);\n            this.parent ?\n                this.parent._reject(e) :\n                wasActive && this.idbtrans && this.idbtrans.abort();\n            return rejection(e);\n        });\n    });\n}\n\nfunction createIndexSpec(name, keyPath, unique, multi, auto, compound, isPrimKey) {\n    return {\n        name,\n        keyPath,\n        unique,\n        multi,\n        auto,\n        compound,\n        src: (unique && !isPrimKey ? '&' : '') + (multi ? '*' : '') + (auto ? \"++\" : \"\") + nameFromKeyPath(keyPath)\n    };\n}\nfunction nameFromKeyPath(keyPath) {\n    return typeof keyPath === 'string' ?\n        keyPath :\n        keyPath ? ('[' + [].join.call(keyPath, '+') + ']') : \"\";\n}\n\nfunction createTableSchema(name, primKey, indexes) {\n    return {\n        name,\n        primKey,\n        indexes,\n        mappedClass: null,\n        idxByName: arrayToObject(indexes, index => [index.name, index])\n    };\n}\n\nfunction safariMultiStoreFix(storeNames) {\n    return storeNames.length === 1 ? storeNames[0] : storeNames;\n}\nlet getMaxKey = (IdbKeyRange) => {\n    try {\n        IdbKeyRange.only([[]]);\n        getMaxKey = () => [[]];\n        return [[]];\n    }\n    catch (e) {\n        getMaxKey = () => maxString;\n        return maxString;\n    }\n};\n\nfunction getKeyExtractor(keyPath) {\n    if (keyPath == null) {\n        return () => undefined;\n    }\n    else if (typeof keyPath === 'string') {\n        return getSinglePathKeyExtractor(keyPath);\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\nfunction getSinglePathKeyExtractor(keyPath) {\n    const split = keyPath.split('.');\n    if (split.length === 1) {\n        return obj => obj[keyPath];\n    }\n    else {\n        return obj => getByKeyPath(obj, keyPath);\n    }\n}\n\nfunction arrayify(arrayLike) {\n    return [].slice.call(arrayLike);\n}\nlet _id_counter = 0;\nfunction getKeyPathAlias(keyPath) {\n    return keyPath == null ?\n        \":id\" :\n        typeof keyPath === 'string' ?\n            keyPath :\n            `[${keyPath.join('+')}]`;\n}\nfunction createDBCore(db, IdbKeyRange, tmpTrans) {\n    function extractSchema(db, trans) {\n        const tables = arrayify(db.objectStoreNames);\n        return {\n            schema: {\n                name: db.name,\n                tables: tables.map(table => trans.objectStore(table)).map(store => {\n                    const { keyPath, autoIncrement } = store;\n                    const compound = isArray(keyPath);\n                    const outbound = keyPath == null;\n                    const indexByKeyPath = {};\n                    const result = {\n                        name: store.name,\n                        primaryKey: {\n                            name: null,\n                            isPrimaryKey: true,\n                            outbound,\n                            compound,\n                            keyPath,\n                            autoIncrement,\n                            unique: true,\n                            extractKey: getKeyExtractor(keyPath)\n                        },\n                        indexes: arrayify(store.indexNames).map(indexName => store.index(indexName))\n                            .map(index => {\n                            const { name, unique, multiEntry, keyPath } = index;\n                            const compound = isArray(keyPath);\n                            const result = {\n                                name,\n                                compound,\n                                keyPath,\n                                unique,\n                                multiEntry,\n                                extractKey: getKeyExtractor(keyPath)\n                            };\n                            indexByKeyPath[getKeyPathAlias(keyPath)] = result;\n                            return result;\n                        }),\n                        getIndexByKeyPath: (keyPath) => indexByKeyPath[getKeyPathAlias(keyPath)]\n                    };\n                    indexByKeyPath[\":id\"] = result.primaryKey;\n                    if (keyPath != null) {\n                        indexByKeyPath[getKeyPathAlias(keyPath)] = result.primaryKey;\n                    }\n                    return result;\n                })\n            },\n            hasGetAll: tables.length > 0 && ('getAll' in trans.objectStore(tables[0])) &&\n                !(typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n                    !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n                    [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604)\n        };\n    }\n    function makeIDBKeyRange(range) {\n        if (range.type === 3 )\n            return null;\n        if (range.type === 4 )\n            throw new Error(\"Cannot convert never type to IDBKeyRange\");\n        const { lower, upper, lowerOpen, upperOpen } = range;\n        const idbRange = lower === undefined ?\n            upper === undefined ?\n                null :\n                IdbKeyRange.upperBound(upper, !!upperOpen) :\n            upper === undefined ?\n                IdbKeyRange.lowerBound(lower, !!lowerOpen) :\n                IdbKeyRange.bound(lower, upper, !!lowerOpen, !!upperOpen);\n        return idbRange;\n    }\n    function createDbCoreTable(tableSchema) {\n        const tableName = tableSchema.name;\n        function mutate({ trans, type, keys, values, range }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const store = trans.objectStore(tableName);\n                const outbound = store.keyPath == null;\n                const isAddOrPut = type === \"put\" || type === \"add\";\n                if (!isAddOrPut && type !== 'delete' && type !== 'deleteRange')\n                    throw new Error(\"Invalid operation type: \" + type);\n                const { length } = keys || values || { length: 1 };\n                if (keys && values && keys.length !== values.length) {\n                    throw new Error(\"Given keys array must have same length as given values array.\");\n                }\n                if (length === 0)\n                    return resolve({ numFailures: 0, failures: {}, results: [], lastResult: undefined });\n                let req;\n                const reqs = [];\n                const failures = [];\n                let numFailures = 0;\n                const errorHandler = event => {\n                    ++numFailures;\n                    preventDefault(event);\n                };\n                if (type === 'deleteRange') {\n                    if (range.type === 4 )\n                        return resolve({ numFailures, failures, results: [], lastResult: undefined });\n                    if (range.type === 3 )\n                        reqs.push(req = store.clear());\n                    else\n                        reqs.push(req = store.delete(makeIDBKeyRange(range)));\n                }\n                else {\n                    const [args1, args2] = isAddOrPut ?\n                        outbound ?\n                            [values, keys] :\n                            [values, null] :\n                        [keys, null];\n                    if (isAddOrPut) {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = (args2 && args2[i] !== undefined ?\n                                store[type](args1[i], args2[i]) :\n                                store[type](args1[i])));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                    else {\n                        for (let i = 0; i < length; ++i) {\n                            reqs.push(req = store[type](args1[i]));\n                            req.onerror = errorHandler;\n                        }\n                    }\n                }\n                const done = event => {\n                    const lastResult = event.target.result;\n                    reqs.forEach((req, i) => req.error != null && (failures[i] = req.error));\n                    resolve({\n                        numFailures,\n                        failures,\n                        results: type === \"delete\" ? keys : reqs.map(req => req.result),\n                        lastResult\n                    });\n                };\n                req.onerror = event => {\n                    errorHandler(event);\n                    done(event);\n                };\n                req.onsuccess = done;\n            });\n        }\n        function openCursor({ trans, values, query, reverse, unique }) {\n            return new Promise((resolve, reject) => {\n                resolve = wrap(resolve);\n                const { index, range } = query;\n                const store = trans.objectStore(tableName);\n                const source = index.isPrimaryKey ?\n                    store :\n                    store.index(index.name);\n                const direction = reverse ?\n                    unique ?\n                        \"prevunique\" :\n                        \"prev\" :\n                    unique ?\n                        \"nextunique\" :\n                        \"next\";\n                const req = values || !('openKeyCursor' in source) ?\n                    source.openCursor(makeIDBKeyRange(range), direction) :\n                    source.openKeyCursor(makeIDBKeyRange(range), direction);\n                req.onerror = eventRejectHandler(reject);\n                req.onsuccess = wrap(ev => {\n                    const cursor = req.result;\n                    if (!cursor) {\n                        resolve(null);\n                        return;\n                    }\n                    cursor.___id = ++_id_counter;\n                    cursor.done = false;\n                    const _cursorContinue = cursor.continue.bind(cursor);\n                    let _cursorContinuePrimaryKey = cursor.continuePrimaryKey;\n                    if (_cursorContinuePrimaryKey)\n                        _cursorContinuePrimaryKey = _cursorContinuePrimaryKey.bind(cursor);\n                    const _cursorAdvance = cursor.advance.bind(cursor);\n                    const doThrowCursorIsNotStarted = () => { throw new Error(\"Cursor not started\"); };\n                    const doThrowCursorIsStopped = () => { throw new Error(\"Cursor not stopped\"); };\n                    cursor.trans = trans;\n                    cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsNotStarted;\n                    cursor.fail = wrap(reject);\n                    cursor.next = function () {\n                        let gotOne = 1;\n                        return this.start(() => gotOne-- ? this.continue() : this.stop()).then(() => this);\n                    };\n                    cursor.start = (callback) => {\n                        const iterationPromise = new Promise((resolveIteration, rejectIteration) => {\n                            resolveIteration = wrap(resolveIteration);\n                            req.onerror = eventRejectHandler(rejectIteration);\n                            cursor.fail = rejectIteration;\n                            cursor.stop = value => {\n                                cursor.stop = cursor.continue = cursor.continuePrimaryKey = cursor.advance = doThrowCursorIsStopped;\n                                resolveIteration(value);\n                            };\n                        });\n                        const guardedCallback = () => {\n                            if (req.result) {\n                                try {\n                                    callback();\n                                }\n                                catch (err) {\n                                    cursor.fail(err);\n                                }\n                            }\n                            else {\n                                cursor.done = true;\n                                cursor.start = () => { throw new Error(\"Cursor behind last entry\"); };\n                                cursor.stop();\n                            }\n                        };\n                        req.onsuccess = wrap(ev => {\n                            req.onsuccess = guardedCallback;\n                            guardedCallback();\n                        });\n                        cursor.continue = _cursorContinue;\n                        cursor.continuePrimaryKey = _cursorContinuePrimaryKey;\n                        cursor.advance = _cursorAdvance;\n                        guardedCallback();\n                        return iterationPromise;\n                    };\n                    resolve(cursor);\n                }, reject);\n            });\n        }\n        function query(hasGetAll) {\n            return (request) => {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const { trans, values, limit, query } = request;\n                    const nonInfinitLimit = limit === Infinity ? undefined : limit;\n                    const { index, range } = query;\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    if (limit === 0)\n                        return resolve({ result: [] });\n                    if (hasGetAll) {\n                        const req = values ?\n                            source.getAll(idbKeyRange, nonInfinitLimit) :\n                            source.getAllKeys(idbKeyRange, nonInfinitLimit);\n                        req.onsuccess = event => resolve({ result: event.target.result });\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                    else {\n                        let count = 0;\n                        const req = values || !('openKeyCursor' in source) ?\n                            source.openCursor(idbKeyRange) :\n                            source.openKeyCursor(idbKeyRange);\n                        const result = [];\n                        req.onsuccess = event => {\n                            const cursor = req.result;\n                            if (!cursor)\n                                return resolve({ result });\n                            result.push(values ? cursor.value : cursor.primaryKey);\n                            if (++count === limit)\n                                return resolve({ result });\n                            cursor.continue();\n                        };\n                        req.onerror = eventRejectHandler(reject);\n                    }\n                });\n            };\n        }\n        return {\n            name: tableName,\n            schema: tableSchema,\n            mutate,\n            getMany({ trans, keys }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const length = keys.length;\n                    const result = new Array(length);\n                    let keyCount = 0;\n                    let callbackCount = 0;\n                    let req;\n                    const successHandler = event => {\n                        const req = event.target;\n                        if ((result[req._pos] = req.result) != null)\n                            ;\n                        if (++callbackCount === keyCount)\n                            resolve(result);\n                    };\n                    const errorHandler = eventRejectHandler(reject);\n                    for (let i = 0; i < length; ++i) {\n                        const key = keys[i];\n                        if (key != null) {\n                            req = store.get(keys[i]);\n                            req._pos = i;\n                            req.onsuccess = successHandler;\n                            req.onerror = errorHandler;\n                            ++keyCount;\n                        }\n                    }\n                    if (keyCount === 0)\n                        resolve(result);\n                });\n            },\n            get({ trans, key }) {\n                return new Promise((resolve, reject) => {\n                    resolve = wrap(resolve);\n                    const store = trans.objectStore(tableName);\n                    const req = store.get(key);\n                    req.onsuccess = event => resolve(event.target.result);\n                    req.onerror = eventRejectHandler(reject);\n                });\n            },\n            query: query(hasGetAll),\n            openCursor,\n            count({ query, trans }) {\n                const { index, range } = query;\n                return new Promise((resolve, reject) => {\n                    const store = trans.objectStore(tableName);\n                    const source = index.isPrimaryKey ? store : store.index(index.name);\n                    const idbKeyRange = makeIDBKeyRange(range);\n                    const req = idbKeyRange ? source.count(idbKeyRange) : source.count();\n                    req.onsuccess = wrap(ev => resolve(ev.target.result));\n                    req.onerror = eventRejectHandler(reject);\n                });\n            }\n        };\n    }\n    const { schema, hasGetAll } = extractSchema(db, tmpTrans);\n    const tables = schema.tables.map(tableSchema => createDbCoreTable(tableSchema));\n    const tableMap = {};\n    tables.forEach(table => tableMap[table.name] = table);\n    return {\n        stack: \"dbcore\",\n        transaction: db.transaction.bind(db),\n        table(name) {\n            const result = tableMap[name];\n            if (!result)\n                throw new Error(`Table '${name}' not found`);\n            return tableMap[name];\n        },\n        MIN_KEY: -Infinity,\n        MAX_KEY: getMaxKey(IdbKeyRange),\n        schema\n    };\n}\n\nfunction createMiddlewareStack(stackImpl, middlewares) {\n    return middlewares.reduce((down, { create }) => ({ ...down, ...create(down) }), stackImpl);\n}\nfunction createMiddlewareStacks(middlewares, idbdb, { IDBKeyRange, indexedDB }, tmpTrans) {\n    const dbcore = createMiddlewareStack(createDBCore(idbdb, IDBKeyRange, tmpTrans), middlewares.dbcore);\n    return {\n        dbcore\n    };\n}\nfunction generateMiddlewareStacks({ _novip: db }, tmpTrans) {\n    const idbdb = tmpTrans.db;\n    const stacks = createMiddlewareStacks(db._middlewares, idbdb, db._deps, tmpTrans);\n    db.core = stacks.dbcore;\n    db.tables.forEach(table => {\n        const tableName = table.name;\n        if (db.core.schema.tables.some(tbl => tbl.name === tableName)) {\n            table.core = db.core.table(tableName);\n            if (db[tableName] instanceof db.Table) {\n                db[tableName].core = table.core;\n            }\n        }\n    });\n}\n\nfunction setApiOnPlace({ _novip: db }, objs, tableNames, dbschema) {\n    tableNames.forEach(tableName => {\n        const schema = dbschema[tableName];\n        objs.forEach(obj => {\n            const propDesc = getPropertyDescriptor(obj, tableName);\n            if (!propDesc || (\"value\" in propDesc && propDesc.value === undefined)) {\n                if (obj === db.Transaction.prototype || obj instanceof db.Transaction) {\n                    setProp(obj, tableName, {\n                        get() { return this.table(tableName); },\n                        set(value) {\n                            defineProperty(this, tableName, { value, writable: true, configurable: true, enumerable: true });\n                        }\n                    });\n                }\n                else {\n                    obj[tableName] = new db.Table(tableName, schema);\n                }\n            }\n        });\n    });\n}\nfunction removeTablesApi({ _novip: db }, objs) {\n    objs.forEach(obj => {\n        for (let key in obj) {\n            if (obj[key] instanceof db.Table)\n                delete obj[key];\n        }\n    });\n}\nfunction lowerVersionFirst(a, b) {\n    return a._cfg.version - b._cfg.version;\n}\nfunction runUpgraders(db, oldVersion, idbUpgradeTrans, reject) {\n    const globalSchema = db._dbSchema;\n    const trans = db._createTransaction('readwrite', db._storeNames, globalSchema);\n    trans.create(idbUpgradeTrans);\n    trans._completion.catch(reject);\n    const rejectTransaction = trans._reject.bind(trans);\n    const transless = PSD.transless || PSD;\n    newScope(() => {\n        PSD.trans = trans;\n        PSD.transless = transless;\n        if (oldVersion === 0) {\n            keys(globalSchema).forEach(tableName => {\n                createTable(idbUpgradeTrans, tableName, globalSchema[tableName].primKey, globalSchema[tableName].indexes);\n            });\n            generateMiddlewareStacks(db, idbUpgradeTrans);\n            DexiePromise.follow(() => db.on.populate.fire(trans)).catch(rejectTransaction);\n        }\n        else\n            updateTablesAndIndexes(db, oldVersion, trans, idbUpgradeTrans).catch(rejectTransaction);\n    });\n}\nfunction updateTablesAndIndexes({ _novip: db }, oldVersion, trans, idbUpgradeTrans) {\n    const queue = [];\n    const versions = db._versions;\n    let globalSchema = db._dbSchema = buildGlobalSchema(db, db.idbdb, idbUpgradeTrans);\n    let anyContentUpgraderHasRun = false;\n    const versToRun = versions.filter(v => v._cfg.version >= oldVersion);\n    versToRun.forEach(version => {\n        queue.push(() => {\n            const oldSchema = globalSchema;\n            const newSchema = version._cfg.dbschema;\n            adjustToExistingIndexNames(db, oldSchema, idbUpgradeTrans);\n            adjustToExistingIndexNames(db, newSchema, idbUpgradeTrans);\n            globalSchema = db._dbSchema = newSchema;\n            const diff = getSchemaDiff(oldSchema, newSchema);\n            diff.add.forEach(tuple => {\n                createTable(idbUpgradeTrans, tuple[0], tuple[1].primKey, tuple[1].indexes);\n            });\n            diff.change.forEach(change => {\n                if (change.recreate) {\n                    throw new exceptions.Upgrade(\"Not yet support for changing primary key\");\n                }\n                else {\n                    const store = idbUpgradeTrans.objectStore(change.name);\n                    change.add.forEach(idx => addIndex(store, idx));\n                    change.change.forEach(idx => {\n                        store.deleteIndex(idx.name);\n                        addIndex(store, idx);\n                    });\n                    change.del.forEach(idxName => store.deleteIndex(idxName));\n                }\n            });\n            const contentUpgrade = version._cfg.contentUpgrade;\n            if (contentUpgrade && version._cfg.version > oldVersion) {\n                generateMiddlewareStacks(db, idbUpgradeTrans);\n                trans._memoizedTables = {};\n                anyContentUpgraderHasRun = true;\n                let upgradeSchema = shallowClone(newSchema);\n                diff.del.forEach(table => {\n                    upgradeSchema[table] = oldSchema[table];\n                });\n                removeTablesApi(db, [db.Transaction.prototype]);\n                setApiOnPlace(db, [db.Transaction.prototype], keys(upgradeSchema), upgradeSchema);\n                trans.schema = upgradeSchema;\n                const contentUpgradeIsAsync = isAsyncFunction(contentUpgrade);\n                if (contentUpgradeIsAsync) {\n                    incrementExpectedAwaits();\n                }\n                let returnValue;\n                const promiseFollowed = DexiePromise.follow(() => {\n                    returnValue = contentUpgrade(trans);\n                    if (returnValue) {\n                        if (contentUpgradeIsAsync) {\n                            var decrementor = decrementExpectedAwaits.bind(null, null);\n                            returnValue.then(decrementor, decrementor);\n                        }\n                    }\n                });\n                return (returnValue && typeof returnValue.then === 'function' ?\n                    DexiePromise.resolve(returnValue) : promiseFollowed.then(() => returnValue));\n            }\n        });\n        queue.push(idbtrans => {\n            if (!anyContentUpgraderHasRun || !hasIEDeleteObjectStoreBug) {\n                const newSchema = version._cfg.dbschema;\n                deleteRemovedTables(newSchema, idbtrans);\n            }\n            removeTablesApi(db, [db.Transaction.prototype]);\n            setApiOnPlace(db, [db.Transaction.prototype], db._storeNames, db._dbSchema);\n            trans.schema = db._dbSchema;\n        });\n    });\n    function runQueue() {\n        return queue.length ? DexiePromise.resolve(queue.shift()(trans.idbtrans)).then(runQueue) :\n            DexiePromise.resolve();\n    }\n    return runQueue().then(() => {\n        createMissingTables(globalSchema, idbUpgradeTrans);\n    });\n}\nfunction getSchemaDiff(oldSchema, newSchema) {\n    const diff = {\n        del: [],\n        add: [],\n        change: []\n    };\n    let table;\n    for (table in oldSchema) {\n        if (!newSchema[table])\n            diff.del.push(table);\n    }\n    for (table in newSchema) {\n        const oldDef = oldSchema[table], newDef = newSchema[table];\n        if (!oldDef) {\n            diff.add.push([table, newDef]);\n        }\n        else {\n            const change = {\n                name: table,\n                def: newDef,\n                recreate: false,\n                del: [],\n                add: [],\n                change: []\n            };\n            if ((\n            '' + (oldDef.primKey.keyPath || '')) !== ('' + (newDef.primKey.keyPath || '')) ||\n                (oldDef.primKey.auto !== newDef.primKey.auto && !isIEOrEdge))\n             {\n                change.recreate = true;\n                diff.change.push(change);\n            }\n            else {\n                const oldIndexes = oldDef.idxByName;\n                const newIndexes = newDef.idxByName;\n                let idxName;\n                for (idxName in oldIndexes) {\n                    if (!newIndexes[idxName])\n                        change.del.push(idxName);\n                }\n                for (idxName in newIndexes) {\n                    const oldIdx = oldIndexes[idxName], newIdx = newIndexes[idxName];\n                    if (!oldIdx)\n                        change.add.push(newIdx);\n                    else if (oldIdx.src !== newIdx.src)\n                        change.change.push(newIdx);\n                }\n                if (change.del.length > 0 || change.add.length > 0 || change.change.length > 0) {\n                    diff.change.push(change);\n                }\n            }\n        }\n    }\n    return diff;\n}\nfunction createTable(idbtrans, tableName, primKey, indexes) {\n    const store = idbtrans.db.createObjectStore(tableName, primKey.keyPath ?\n        { keyPath: primKey.keyPath, autoIncrement: primKey.auto } :\n        { autoIncrement: primKey.auto });\n    indexes.forEach(idx => addIndex(store, idx));\n    return store;\n}\nfunction createMissingTables(newSchema, idbtrans) {\n    keys(newSchema).forEach(tableName => {\n        if (!idbtrans.db.objectStoreNames.contains(tableName)) {\n            createTable(idbtrans, tableName, newSchema[tableName].primKey, newSchema[tableName].indexes);\n        }\n    });\n}\nfunction deleteRemovedTables(newSchema, idbtrans) {\n    [].slice.call(idbtrans.db.objectStoreNames).forEach(storeName => newSchema[storeName] == null && idbtrans.db.deleteObjectStore(storeName));\n}\nfunction addIndex(store, idx) {\n    store.createIndex(idx.name, idx.keyPath, { unique: idx.unique, multiEntry: idx.multi });\n}\nfunction buildGlobalSchema(db, idbdb, tmpTrans) {\n    const globalSchema = {};\n    const dbStoreNames = slice(idbdb.objectStoreNames, 0);\n    dbStoreNames.forEach(storeName => {\n        const store = tmpTrans.objectStore(storeName);\n        let keyPath = store.keyPath;\n        const primKey = createIndexSpec(nameFromKeyPath(keyPath), keyPath || \"\", false, false, !!store.autoIncrement, keyPath && typeof keyPath !== \"string\", true);\n        const indexes = [];\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const idbindex = store.index(store.indexNames[j]);\n            keyPath = idbindex.keyPath;\n            var index = createIndexSpec(idbindex.name, keyPath, !!idbindex.unique, !!idbindex.multiEntry, false, keyPath && typeof keyPath !== \"string\", false);\n            indexes.push(index);\n        }\n        globalSchema[storeName] = createTableSchema(storeName, primKey, indexes);\n    });\n    return globalSchema;\n}\nfunction readGlobalSchema({ _novip: db }, idbdb, tmpTrans) {\n    db.verno = idbdb.version / 10;\n    const globalSchema = db._dbSchema = buildGlobalSchema(db, idbdb, tmpTrans);\n    db._storeNames = slice(idbdb.objectStoreNames, 0);\n    setApiOnPlace(db, [db._allTables], keys(globalSchema), globalSchema);\n}\nfunction verifyInstalledSchema(db, tmpTrans) {\n    const installedSchema = buildGlobalSchema(db, db.idbdb, tmpTrans);\n    const diff = getSchemaDiff(installedSchema, db._dbSchema);\n    return !(diff.add.length || diff.change.some(ch => ch.add.length || ch.change.length));\n}\nfunction adjustToExistingIndexNames({ _novip: db }, schema, idbtrans) {\n    const storeNames = idbtrans.db.objectStoreNames;\n    for (let i = 0; i < storeNames.length; ++i) {\n        const storeName = storeNames[i];\n        const store = idbtrans.objectStore(storeName);\n        db._hasGetAll = 'getAll' in store;\n        for (let j = 0; j < store.indexNames.length; ++j) {\n            const indexName = store.indexNames[j];\n            const keyPath = store.index(indexName).keyPath;\n            const dexieName = typeof keyPath === 'string' ? keyPath : \"[\" + slice(keyPath).join('+') + \"]\";\n            if (schema[storeName]) {\n                const indexSpec = schema[storeName].idxByName[dexieName];\n                if (indexSpec) {\n                    indexSpec.name = indexName;\n                    delete schema[storeName].idxByName[dexieName];\n                    schema[storeName].idxByName[indexName] = indexSpec;\n                }\n            }\n        }\n    }\n    if (typeof navigator !== 'undefined' && /Safari/.test(navigator.userAgent) &&\n        !/(Chrome\\/|Edge\\/)/.test(navigator.userAgent) &&\n        _global.WorkerGlobalScope && _global instanceof _global.WorkerGlobalScope &&\n        [].concat(navigator.userAgent.match(/Safari\\/(\\d*)/))[1] < 604) {\n        db._hasGetAll = false;\n    }\n}\nfunction parseIndexSyntax(primKeyAndIndexes) {\n    return primKeyAndIndexes.split(',').map((index, indexNum) => {\n        index = index.trim();\n        const name = index.replace(/([&*]|\\+\\+)/g, \"\");\n        const keyPath = /^\\[/.test(name) ? name.match(/^\\[(.*)\\]$/)[1].split('+') : name;\n        return createIndexSpec(name, keyPath || null, /\\&/.test(index), /\\*/.test(index), /\\+\\+/.test(index), isArray(keyPath), indexNum === 0);\n    });\n}\n\nclass Version {\n    _parseStoresSpec(stores, outSchema) {\n        keys(stores).forEach(tableName => {\n            if (stores[tableName] !== null) {\n                var indexes = parseIndexSyntax(stores[tableName]);\n                var primKey = indexes.shift();\n                if (primKey.multi)\n                    throw new exceptions.Schema(\"Primary key cannot be multi-valued\");\n                indexes.forEach(idx => {\n                    if (idx.auto)\n                        throw new exceptions.Schema(\"Only primary key can be marked as autoIncrement (++)\");\n                    if (!idx.keyPath)\n                        throw new exceptions.Schema(\"Index must have a name and cannot be an empty string\");\n                });\n                outSchema[tableName] = createTableSchema(tableName, primKey, indexes);\n            }\n        });\n    }\n    stores(stores) {\n        const db = this.db;\n        this._cfg.storesSource = this._cfg.storesSource ?\n            extend(this._cfg.storesSource, stores) :\n            stores;\n        const versions = db._versions;\n        const storesSpec = {};\n        let dbschema = {};\n        versions.forEach(version => {\n            extend(storesSpec, version._cfg.storesSource);\n            dbschema = (version._cfg.dbschema = {});\n            version._parseStoresSpec(storesSpec, dbschema);\n        });\n        db._dbSchema = dbschema;\n        removeTablesApi(db, [db._allTables, db, db.Transaction.prototype]);\n        setApiOnPlace(db, [db._allTables, db, db.Transaction.prototype, this._cfg.tables], keys(dbschema), dbschema);\n        db._storeNames = keys(dbschema);\n        return this;\n    }\n    upgrade(upgradeFunction) {\n        this._cfg.contentUpgrade = promisableChain(this._cfg.contentUpgrade || nop, upgradeFunction);\n        return this;\n    }\n}\n\nfunction createVersionConstructor(db) {\n    return makeClassConstructor(Version.prototype, function Version(versionNumber) {\n        this.db = db;\n        this._cfg = {\n            version: versionNumber,\n            storesSource: null,\n            dbschema: {},\n            tables: {},\n            contentUpgrade: null\n        };\n    });\n}\n\nfunction getDbNamesTable(indexedDB, IDBKeyRange) {\n    let dbNamesDB = indexedDB[\"_dbNamesDB\"];\n    if (!dbNamesDB) {\n        dbNamesDB = indexedDB[\"_dbNamesDB\"] = new Dexie$1(DBNAMES_DB, {\n            addons: [],\n            indexedDB,\n            IDBKeyRange,\n        });\n        dbNamesDB.version(1).stores({ dbnames: \"name\" });\n    }\n    return dbNamesDB.table(\"dbnames\");\n}\nfunction hasDatabasesNative(indexedDB) {\n    return indexedDB && typeof indexedDB.databases === \"function\";\n}\nfunction getDatabaseNames({ indexedDB, IDBKeyRange, }) {\n    return hasDatabasesNative(indexedDB)\n        ? Promise.resolve(indexedDB.databases()).then((infos) => infos\n            .map((info) => info.name)\n            .filter((name) => name !== DBNAMES_DB))\n        : getDbNamesTable(indexedDB, IDBKeyRange).toCollection().primaryKeys();\n}\nfunction _onDatabaseCreated({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).put({ name }).catch(nop);\n}\nfunction _onDatabaseDeleted({ indexedDB, IDBKeyRange }, name) {\n    !hasDatabasesNative(indexedDB) &&\n        name !== DBNAMES_DB &&\n        getDbNamesTable(indexedDB, IDBKeyRange).delete(name).catch(nop);\n}\n\nfunction vip(fn) {\n    return newScope(function () {\n        PSD.letThrough = true;\n        return fn();\n    });\n}\n\nfunction idbReady() {\n    var isSafari = !navigator.userAgentData &&\n        /Safari\\//.test(navigator.userAgent) &&\n        !/Chrom(e|ium)\\//.test(navigator.userAgent);\n    if (!isSafari || !indexedDB.databases)\n        return Promise.resolve();\n    var intervalId;\n    return new Promise(function (resolve) {\n        var tryIdb = function () { return indexedDB.databases().finally(resolve); };\n        intervalId = setInterval(tryIdb, 100);\n        tryIdb();\n    }).finally(function () { return clearInterval(intervalId); });\n}\n\nfunction dexieOpen(db) {\n    const state = db._state;\n    const { indexedDB } = db._deps;\n    if (state.isBeingOpened || db.idbdb)\n        return state.dbReadyPromise.then(() => state.dbOpenError ?\n            rejection(state.dbOpenError) :\n            db);\n    debug && (state.openCanceller._stackHolder = getErrorWithStack());\n    state.isBeingOpened = true;\n    state.dbOpenError = null;\n    state.openComplete = false;\n    const openCanceller = state.openCanceller;\n    function throwIfCancelled() {\n        if (state.openCanceller !== openCanceller)\n            throw new exceptions.DatabaseClosed('db.open() was cancelled');\n    }\n    let resolveDbReady = state.dbReadyResolve,\n    upgradeTransaction = null, wasCreated = false;\n    return DexiePromise.race([openCanceller, (typeof navigator === 'undefined' ? DexiePromise.resolve() : idbReady()).then(() => new DexiePromise((resolve, reject) => {\n            throwIfCancelled();\n            if (!indexedDB)\n                throw new exceptions.MissingAPI();\n            const dbName = db.name;\n            const req = state.autoSchema ?\n                indexedDB.open(dbName) :\n                indexedDB.open(dbName, Math.round(db.verno * 10));\n            if (!req)\n                throw new exceptions.MissingAPI();\n            req.onerror = eventRejectHandler(reject);\n            req.onblocked = wrap(db._fireOnBlocked);\n            req.onupgradeneeded = wrap(e => {\n                upgradeTransaction = req.transaction;\n                if (state.autoSchema && !db._options.allowEmptyDB) {\n                    req.onerror = preventDefault;\n                    upgradeTransaction.abort();\n                    req.result.close();\n                    const delreq = indexedDB.deleteDatabase(dbName);\n                    delreq.onsuccess = delreq.onerror = wrap(() => {\n                        reject(new exceptions.NoSuchDatabase(`Database ${dbName} doesnt exist`));\n                    });\n                }\n                else {\n                    upgradeTransaction.onerror = eventRejectHandler(reject);\n                    var oldVer = e.oldVersion > Math.pow(2, 62) ? 0 : e.oldVersion;\n                    wasCreated = oldVer < 1;\n                    db._novip.idbdb = req.result;\n                    runUpgraders(db, oldVer / 10, upgradeTransaction, reject);\n                }\n            }, reject);\n            req.onsuccess = wrap(() => {\n                upgradeTransaction = null;\n                const idbdb = db._novip.idbdb = req.result;\n                const objectStoreNames = slice(idbdb.objectStoreNames);\n                if (objectStoreNames.length > 0)\n                    try {\n                        const tmpTrans = idbdb.transaction(safariMultiStoreFix(objectStoreNames), 'readonly');\n                        if (state.autoSchema)\n                            readGlobalSchema(db, idbdb, tmpTrans);\n                        else {\n                            adjustToExistingIndexNames(db, db._dbSchema, tmpTrans);\n                            if (!verifyInstalledSchema(db, tmpTrans)) {\n                                console.warn(`Dexie SchemaDiff: Schema was extended without increasing the number passed to db.version(). Some queries may fail.`);\n                            }\n                        }\n                        generateMiddlewareStacks(db, tmpTrans);\n                    }\n                    catch (e) {\n                    }\n                connections.push(db);\n                idbdb.onversionchange = wrap(ev => {\n                    state.vcFired = true;\n                    db.on(\"versionchange\").fire(ev);\n                });\n                idbdb.onclose = wrap(ev => {\n                    db.on(\"close\").fire(ev);\n                });\n                if (wasCreated)\n                    _onDatabaseCreated(db._deps, dbName);\n                resolve();\n            }, reject);\n        }))]).then(() => {\n        throwIfCancelled();\n        state.onReadyBeingFired = [];\n        return DexiePromise.resolve(vip(() => db.on.ready.fire(db.vip))).then(function fireRemainders() {\n            if (state.onReadyBeingFired.length > 0) {\n                let remainders = state.onReadyBeingFired.reduce(promisableChain, nop);\n                state.onReadyBeingFired = [];\n                return DexiePromise.resolve(vip(() => remainders(db.vip))).then(fireRemainders);\n            }\n        });\n    }).finally(() => {\n        state.onReadyBeingFired = null;\n        state.isBeingOpened = false;\n    }).then(() => {\n        return db;\n    }).catch(err => {\n        state.dbOpenError = err;\n        try {\n            upgradeTransaction && upgradeTransaction.abort();\n        }\n        catch (_a) { }\n        if (openCanceller === state.openCanceller) {\n            db._close();\n        }\n        return rejection(err);\n    }).finally(() => {\n        state.openComplete = true;\n        resolveDbReady();\n    });\n}\n\nfunction awaitIterator(iterator) {\n    var callNext = result => iterator.next(result), doThrow = error => iterator.throw(error), onSuccess = step(callNext), onError = step(doThrow);\n    function step(getNext) {\n        return (val) => {\n            var next = getNext(val), value = next.value;\n            return next.done ? value :\n                (!value || typeof value.then !== 'function' ?\n                    isArray(value) ? Promise.all(value).then(onSuccess, onError) : onSuccess(value) :\n                    value.then(onSuccess, onError));\n        };\n    }\n    return step(callNext)();\n}\n\nfunction extractTransactionArgs(mode, _tableArgs_, scopeFunc) {\n    var i = arguments.length;\n    if (i < 2)\n        throw new exceptions.InvalidArgument(\"Too few arguments\");\n    var args = new Array(i - 1);\n    while (--i)\n        args[i - 1] = arguments[i];\n    scopeFunc = args.pop();\n    var tables = flatten(args);\n    return [mode, tables, scopeFunc];\n}\nfunction enterTransactionScope(db, mode, storeNames, parentTransaction, scopeFunc) {\n    return DexiePromise.resolve().then(() => {\n        const transless = PSD.transless || PSD;\n        const trans = db._createTransaction(mode, storeNames, db._dbSchema, parentTransaction);\n        const zoneProps = {\n            trans: trans,\n            transless: transless\n        };\n        if (parentTransaction) {\n            trans.idbtrans = parentTransaction.idbtrans;\n        }\n        else {\n            trans.create();\n        }\n        const scopeFuncIsAsync = isAsyncFunction(scopeFunc);\n        if (scopeFuncIsAsync) {\n            incrementExpectedAwaits();\n        }\n        let returnValue;\n        const promiseFollowed = DexiePromise.follow(() => {\n            returnValue = scopeFunc.call(trans, trans);\n            if (returnValue) {\n                if (scopeFuncIsAsync) {\n                    var decrementor = decrementExpectedAwaits.bind(null, null);\n                    returnValue.then(decrementor, decrementor);\n                }\n                else if (typeof returnValue.next === 'function' && typeof returnValue.throw === 'function') {\n                    returnValue = awaitIterator(returnValue);\n                }\n            }\n        }, zoneProps);\n        return (returnValue && typeof returnValue.then === 'function' ?\n            DexiePromise.resolve(returnValue).then(x => trans.active ?\n                x\n                : rejection(new exceptions.PrematureCommit(\"Transaction committed too early. See http://bit.ly/2kdckMn\")))\n            : promiseFollowed.then(() => returnValue)).then(x => {\n            if (parentTransaction)\n                trans._resolve();\n            return trans._completion.then(() => x);\n        }).catch(e => {\n            trans._reject(e);\n            return rejection(e);\n        });\n    });\n}\n\nfunction pad(a, value, count) {\n    const result = isArray(a) ? a.slice() : [a];\n    for (let i = 0; i < count; ++i)\n        result.push(value);\n    return result;\n}\nfunction createVirtualIndexMiddleware(down) {\n    return {\n        ...down,\n        table(tableName) {\n            const table = down.table(tableName);\n            const { schema } = table;\n            const indexLookup = {};\n            const allVirtualIndexes = [];\n            function addVirtualIndexes(keyPath, keyTail, lowLevelIndex) {\n                const keyPathAlias = getKeyPathAlias(keyPath);\n                const indexList = (indexLookup[keyPathAlias] = indexLookup[keyPathAlias] || []);\n                const keyLength = keyPath == null ? 0 : typeof keyPath === 'string' ? 1 : keyPath.length;\n                const isVirtual = keyTail > 0;\n                const virtualIndex = {\n                    ...lowLevelIndex,\n                    isVirtual,\n                    keyTail,\n                    keyLength,\n                    extractKey: getKeyExtractor(keyPath),\n                    unique: !isVirtual && lowLevelIndex.unique\n                };\n                indexList.push(virtualIndex);\n                if (!virtualIndex.isPrimaryKey) {\n                    allVirtualIndexes.push(virtualIndex);\n                }\n                if (keyLength > 1) {\n                    const virtualKeyPath = keyLength === 2 ?\n                        keyPath[0] :\n                        keyPath.slice(0, keyLength - 1);\n                    addVirtualIndexes(virtualKeyPath, keyTail + 1, lowLevelIndex);\n                }\n                indexList.sort((a, b) => a.keyTail - b.keyTail);\n                return virtualIndex;\n            }\n            const primaryKey = addVirtualIndexes(schema.primaryKey.keyPath, 0, schema.primaryKey);\n            indexLookup[\":id\"] = [primaryKey];\n            for (const index of schema.indexes) {\n                addVirtualIndexes(index.keyPath, 0, index);\n            }\n            function findBestIndex(keyPath) {\n                const result = indexLookup[getKeyPathAlias(keyPath)];\n                return result && result[0];\n            }\n            function translateRange(range, keyTail) {\n                return {\n                    type: range.type === 1  ?\n                        2  :\n                        range.type,\n                    lower: pad(range.lower, range.lowerOpen ? down.MAX_KEY : down.MIN_KEY, keyTail),\n                    lowerOpen: true,\n                    upper: pad(range.upper, range.upperOpen ? down.MIN_KEY : down.MAX_KEY, keyTail),\n                    upperOpen: true\n                };\n            }\n            function translateRequest(req) {\n                const index = req.query.index;\n                return index.isVirtual ? {\n                    ...req,\n                    query: {\n                        index,\n                        range: translateRange(req.query.range, index.keyTail)\n                    }\n                } : req;\n            }\n            const result = {\n                ...table,\n                schema: {\n                    ...schema,\n                    primaryKey,\n                    indexes: allVirtualIndexes,\n                    getIndexByKeyPath: findBestIndex\n                },\n                count(req) {\n                    return table.count(translateRequest(req));\n                },\n                query(req) {\n                    return table.query(translateRequest(req));\n                },\n                openCursor(req) {\n                    const { keyTail, isVirtual, keyLength } = req.query.index;\n                    if (!isVirtual)\n                        return table.openCursor(req);\n                    function createVirtualCursor(cursor) {\n                        function _continue(key) {\n                            key != null ?\n                                cursor.continue(pad(key, req.reverse ? down.MAX_KEY : down.MIN_KEY, keyTail)) :\n                                req.unique ?\n                                    cursor.continue(cursor.key.slice(0, keyLength)\n                                        .concat(req.reverse\n                                        ? down.MIN_KEY\n                                        : down.MAX_KEY, keyTail)) :\n                                    cursor.continue();\n                        }\n                        const virtualCursor = Object.create(cursor, {\n                            continue: { value: _continue },\n                            continuePrimaryKey: {\n                                value(key, primaryKey) {\n                                    cursor.continuePrimaryKey(pad(key, down.MAX_KEY, keyTail), primaryKey);\n                                }\n                            },\n                            primaryKey: {\n                                get() {\n                                    return cursor.primaryKey;\n                                }\n                            },\n                            key: {\n                                get() {\n                                    const key = cursor.key;\n                                    return keyLength === 1 ?\n                                        key[0] :\n                                        key.slice(0, keyLength);\n                                }\n                            },\n                            value: {\n                                get() {\n                                    return cursor.value;\n                                }\n                            }\n                        });\n                        return virtualCursor;\n                    }\n                    return table.openCursor(translateRequest(req))\n                        .then(cursor => cursor && createVirtualCursor(cursor));\n                }\n            };\n            return result;\n        }\n    };\n}\nconst virtualIndexMiddleware = {\n    stack: \"dbcore\",\n    name: \"VirtualIndexMiddleware\",\n    level: 1,\n    create: createVirtualIndexMiddleware\n};\n\nfunction getObjectDiff(a, b, rv, prfx) {\n    rv = rv || {};\n    prfx = prfx || '';\n    keys(a).forEach((prop) => {\n        if (!hasOwn(b, prop)) {\n            rv[prfx + prop] = undefined;\n        }\n        else {\n            var ap = a[prop], bp = b[prop];\n            if (typeof ap === 'object' && typeof bp === 'object' && ap && bp) {\n                const apTypeName = toStringTag(ap);\n                const bpTypeName = toStringTag(bp);\n                if (apTypeName !== bpTypeName) {\n                    rv[prfx + prop] = b[prop];\n                }\n                else if (apTypeName === 'Object') {\n                    getObjectDiff(ap, bp, rv, prfx + prop + '.');\n                }\n                else if (ap !== bp) {\n                    rv[prfx + prop] = b[prop];\n                }\n            }\n            else if (ap !== bp)\n                rv[prfx + prop] = b[prop];\n        }\n    });\n    keys(b).forEach((prop) => {\n        if (!hasOwn(a, prop)) {\n            rv[prfx + prop] = b[prop];\n        }\n    });\n    return rv;\n}\n\nfunction getEffectiveKeys(primaryKey, req) {\n    if (req.type === 'delete')\n        return req.keys;\n    return req.keys || req.values.map(primaryKey.extractKey);\n}\n\nconst hooksMiddleware = {\n    stack: \"dbcore\",\n    name: \"HooksMiddleware\",\n    level: 2,\n    create: (downCore) => ({\n        ...downCore,\n        table(tableName) {\n            const downTable = downCore.table(tableName);\n            const { primaryKey } = downTable.schema;\n            const tableMiddleware = {\n                ...downTable,\n                mutate(req) {\n                    const dxTrans = PSD.trans;\n                    const { deleting, creating, updating } = dxTrans.table(tableName).hook;\n                    switch (req.type) {\n                        case 'add':\n                            if (creating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'put':\n                            if (creating.fire === nop && updating.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'delete':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => addPutOrDelete(req), true);\n                        case 'deleteRange':\n                            if (deleting.fire === nop)\n                                break;\n                            return dxTrans._promise('readwrite', () => deleteRange(req), true);\n                    }\n                    return downTable.mutate(req);\n                    function addPutOrDelete(req) {\n                        const dxTrans = PSD.trans;\n                        const keys = req.keys || getEffectiveKeys(primaryKey, req);\n                        if (!keys)\n                            throw new Error(\"Keys missing\");\n                        req = req.type === 'add' || req.type === 'put' ?\n                            { ...req, keys } :\n                            { ...req };\n                        if (req.type !== 'delete')\n                            req.values = [...req.values];\n                        if (req.keys)\n                            req.keys = [...req.keys];\n                        return getExistingValues(downTable, req, keys).then(existingValues => {\n                            const contexts = keys.map((key, i) => {\n                                const existingValue = existingValues[i];\n                                const ctx = { onerror: null, onsuccess: null };\n                                if (req.type === 'delete') {\n                                    deleting.fire.call(ctx, key, existingValue, dxTrans);\n                                }\n                                else if (req.type === 'add' || existingValue === undefined) {\n                                    const generatedPrimaryKey = creating.fire.call(ctx, key, req.values[i], dxTrans);\n                                    if (key == null && generatedPrimaryKey != null) {\n                                        key = generatedPrimaryKey;\n                                        req.keys[i] = key;\n                                        if (!primaryKey.outbound) {\n                                            setByKeyPath(req.values[i], primaryKey.keyPath, key);\n                                        }\n                                    }\n                                }\n                                else {\n                                    const objectDiff = getObjectDiff(existingValue, req.values[i]);\n                                    const additionalChanges = updating.fire.call(ctx, objectDiff, key, existingValue, dxTrans);\n                                    if (additionalChanges) {\n                                        const requestedValue = req.values[i];\n                                        Object.keys(additionalChanges).forEach(keyPath => {\n                                            if (hasOwn(requestedValue, keyPath)) {\n                                                requestedValue[keyPath] = additionalChanges[keyPath];\n                                            }\n                                            else {\n                                                setByKeyPath(requestedValue, keyPath, additionalChanges[keyPath]);\n                                            }\n                                        });\n                                    }\n                                }\n                                return ctx;\n                            });\n                            return downTable.mutate(req).then(({ failures, results, numFailures, lastResult }) => {\n                                for (let i = 0; i < keys.length; ++i) {\n                                    const primKey = results ? results[i] : keys[i];\n                                    const ctx = contexts[i];\n                                    if (primKey == null) {\n                                        ctx.onerror && ctx.onerror(failures[i]);\n                                    }\n                                    else {\n                                        ctx.onsuccess && ctx.onsuccess(req.type === 'put' && existingValues[i] ?\n                                            req.values[i] :\n                                            primKey\n                                        );\n                                    }\n                                }\n                                return { failures, results, numFailures, lastResult };\n                            }).catch(error => {\n                                contexts.forEach(ctx => ctx.onerror && ctx.onerror(error));\n                                return Promise.reject(error);\n                            });\n                        });\n                    }\n                    function deleteRange(req) {\n                        return deleteNextChunk(req.trans, req.range, 10000);\n                    }\n                    function deleteNextChunk(trans, range, limit) {\n                        return downTable.query({ trans, values: false, query: { index: primaryKey, range }, limit })\n                            .then(({ result }) => {\n                            return addPutOrDelete({ type: 'delete', keys: result, trans }).then(res => {\n                                if (res.numFailures > 0)\n                                    return Promise.reject(res.failures[0]);\n                                if (result.length < limit) {\n                                    return { failures: [], numFailures: 0, lastResult: undefined };\n                                }\n                                else {\n                                    return deleteNextChunk(trans, { ...range, lower: result[result.length - 1], lowerOpen: true }, limit);\n                                }\n                            });\n                        });\n                    }\n                }\n            };\n            return tableMiddleware;\n        },\n    })\n};\nfunction getExistingValues(table, req, effectiveKeys) {\n    return req.type === \"add\"\n        ? Promise.resolve([])\n        : table.getMany({ trans: req.trans, keys: effectiveKeys, cache: \"immutable\" });\n}\n\nfunction getFromTransactionCache(keys, cache, clone) {\n    try {\n        if (!cache)\n            return null;\n        if (cache.keys.length < keys.length)\n            return null;\n        const result = [];\n        for (let i = 0, j = 0; i < cache.keys.length && j < keys.length; ++i) {\n            if (cmp(cache.keys[i], keys[j]) !== 0)\n                continue;\n            result.push(clone ? deepClone(cache.values[i]) : cache.values[i]);\n            ++j;\n        }\n        return result.length === keys.length ? result : null;\n    }\n    catch (_a) {\n        return null;\n    }\n}\nconst cacheExistingValuesMiddleware = {\n    stack: \"dbcore\",\n    level: -1,\n    create: (core) => {\n        return {\n            table: (tableName) => {\n                const table = core.table(tableName);\n                return {\n                    ...table,\n                    getMany: (req) => {\n                        if (!req.cache) {\n                            return table.getMany(req);\n                        }\n                        const cachedResult = getFromTransactionCache(req.keys, req.trans[\"_cache\"], req.cache === \"clone\");\n                        if (cachedResult) {\n                            return DexiePromise.resolve(cachedResult);\n                        }\n                        return table.getMany(req).then((res) => {\n                            req.trans[\"_cache\"] = {\n                                keys: req.keys,\n                                values: req.cache === \"clone\" ? deepClone(res) : res,\n                            };\n                            return res;\n                        });\n                    },\n                    mutate: (req) => {\n                        if (req.type !== \"add\")\n                            req.trans[\"_cache\"] = null;\n                        return table.mutate(req);\n                    },\n                };\n            },\n        };\n    },\n};\n\nfunction isEmptyRange(node) {\n    return !(\"from\" in node);\n}\nconst RangeSet = function (fromOrTree, to) {\n    if (this) {\n        extend(this, arguments.length ? { d: 1, from: fromOrTree, to: arguments.length > 1 ? to : fromOrTree } : { d: 0 });\n    }\n    else {\n        const rv = new RangeSet();\n        if (fromOrTree && (\"d\" in fromOrTree)) {\n            extend(rv, fromOrTree);\n        }\n        return rv;\n    }\n};\nprops(RangeSet.prototype, {\n    add(rangeSet) {\n        mergeRanges(this, rangeSet);\n        return this;\n    },\n    addKey(key) {\n        addRange(this, key, key);\n        return this;\n    },\n    addKeys(keys) {\n        keys.forEach(key => addRange(this, key, key));\n        return this;\n    },\n    [iteratorSymbol]() {\n        return getRangeSetIterator(this);\n    }\n});\nfunction addRange(target, from, to) {\n    const diff = cmp(from, to);\n    if (isNaN(diff))\n        return;\n    if (diff > 0)\n        throw RangeError();\n    if (isEmptyRange(target))\n        return extend(target, { from, to, d: 1 });\n    const left = target.l;\n    const right = target.r;\n    if (cmp(to, target.from) < 0) {\n        left\n            ? addRange(left, from, to)\n            : (target.l = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.to) > 0) {\n        right\n            ? addRange(right, from, to)\n            : (target.r = { from, to, d: 1, l: null, r: null });\n        return rebalance(target);\n    }\n    if (cmp(from, target.from) < 0) {\n        target.from = from;\n        target.l = null;\n        target.d = right ? right.d + 1 : 1;\n    }\n    if (cmp(to, target.to) > 0) {\n        target.to = to;\n        target.r = null;\n        target.d = target.l ? target.l.d + 1 : 1;\n    }\n    const rightWasCutOff = !target.r;\n    if (left && !target.l) {\n        mergeRanges(target, left);\n    }\n    if (right && rightWasCutOff) {\n        mergeRanges(target, right);\n    }\n}\nfunction mergeRanges(target, newSet) {\n    function _addRangeSet(target, { from, to, l, r }) {\n        addRange(target, from, to);\n        if (l)\n            _addRangeSet(target, l);\n        if (r)\n            _addRangeSet(target, r);\n    }\n    if (!isEmptyRange(newSet))\n        _addRangeSet(target, newSet);\n}\nfunction rangesOverlap(rangeSet1, rangeSet2) {\n    const i1 = getRangeSetIterator(rangeSet2);\n    let nextResult1 = i1.next();\n    if (nextResult1.done)\n        return false;\n    let a = nextResult1.value;\n    const i2 = getRangeSetIterator(rangeSet1);\n    let nextResult2 = i2.next(a.from);\n    let b = nextResult2.value;\n    while (!nextResult1.done && !nextResult2.done) {\n        if (cmp(b.from, a.to) <= 0 && cmp(b.to, a.from) >= 0)\n            return true;\n        cmp(a.from, b.from) < 0\n            ? (a = (nextResult1 = i1.next(b.from)).value)\n            : (b = (nextResult2 = i2.next(a.from)).value);\n    }\n    return false;\n}\nfunction getRangeSetIterator(node) {\n    let state = isEmptyRange(node) ? null : { s: 0, n: node };\n    return {\n        next(key) {\n            const keyProvided = arguments.length > 0;\n            while (state) {\n                switch (state.s) {\n                    case 0:\n                        state.s = 1;\n                        if (keyProvided) {\n                            while (state.n.l && cmp(key, state.n.from) < 0)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                        else {\n                            while (state.n.l)\n                                state = { up: state, n: state.n.l, s: 1 };\n                        }\n                    case 1:\n                        state.s = 2;\n                        if (!keyProvided || cmp(key, state.n.to) <= 0)\n                            return { value: state.n, done: false };\n                    case 2:\n                        if (state.n.r) {\n                            state.s = 3;\n                            state = { up: state, n: state.n.r, s: 0 };\n                            continue;\n                        }\n                    case 3:\n                        state = state.up;\n                }\n            }\n            return { done: true };\n        },\n    };\n}\nfunction rebalance(target) {\n    var _a, _b;\n    const diff = (((_a = target.r) === null || _a === void 0 ? void 0 : _a.d) || 0) - (((_b = target.l) === null || _b === void 0 ? void 0 : _b.d) || 0);\n    const r = diff > 1 ? \"r\" : diff < -1 ? \"l\" : \"\";\n    if (r) {\n        const l = r === \"r\" ? \"l\" : \"r\";\n        const rootClone = { ...target };\n        const oldRootRight = target[r];\n        target.from = oldRootRight.from;\n        target.to = oldRootRight.to;\n        target[r] = oldRootRight[r];\n        rootClone[r] = oldRootRight[l];\n        target[l] = rootClone;\n        rootClone.d = computeDepth(rootClone);\n    }\n    target.d = computeDepth(target);\n}\nfunction computeDepth({ r, l }) {\n    return (r ? (l ? Math.max(r.d, l.d) : r.d) : l ? l.d : 0) + 1;\n}\n\nconst observabilityMiddleware = {\n    stack: \"dbcore\",\n    level: 0,\n    create: (core) => {\n        const dbName = core.schema.name;\n        const FULL_RANGE = new RangeSet(core.MIN_KEY, core.MAX_KEY);\n        return {\n            ...core,\n            table: (tableName) => {\n                const table = core.table(tableName);\n                const { schema } = table;\n                const { primaryKey } = schema;\n                const { extractKey, outbound } = primaryKey;\n                const tableClone = {\n                    ...table,\n                    mutate: (req) => {\n                        const trans = req.trans;\n                        const mutatedParts = trans.mutatedParts || (trans.mutatedParts = {});\n                        const getRangeSet = (indexName) => {\n                            const part = `idb://${dbName}/${tableName}/${indexName}`;\n                            return (mutatedParts[part] ||\n                                (mutatedParts[part] = new RangeSet()));\n                        };\n                        const pkRangeSet = getRangeSet(\"\");\n                        const delsRangeSet = getRangeSet(\":dels\");\n                        const { type } = req;\n                        let [keys, newObjs] = req.type === \"deleteRange\"\n                            ? [req.range]\n                            : req.type === \"delete\"\n                                ? [req.keys]\n                                : req.values.length < 50\n                                    ? [[], req.values]\n                                    : [];\n                        const oldCache = req.trans[\"_cache\"];\n                        return table.mutate(req).then((res) => {\n                            if (isArray(keys)) {\n                                if (type !== \"delete\")\n                                    keys = res.results;\n                                pkRangeSet.addKeys(keys);\n                                const oldObjs = getFromTransactionCache(keys, oldCache);\n                                if (!oldObjs && type !== \"add\") {\n                                    delsRangeSet.addKeys(keys);\n                                }\n                                if (oldObjs || newObjs) {\n                                    trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs);\n                                }\n                            }\n                            else if (keys) {\n                                const range = { from: keys.lower, to: keys.upper };\n                                delsRangeSet.add(range);\n                                pkRangeSet.add(range);\n                            }\n                            else {\n                                pkRangeSet.add(FULL_RANGE);\n                                delsRangeSet.add(FULL_RANGE);\n                                schema.indexes.forEach(idx => getRangeSet(idx.name).add(FULL_RANGE));\n                            }\n                            return res;\n                        });\n                    },\n                };\n                const getRange = ({ query: { index, range }, }) => {\n                    var _a, _b;\n                    return [\n                        index,\n                        new RangeSet((_a = range.lower) !== null && _a !== void 0 ? _a : core.MIN_KEY, (_b = range.upper) !== null && _b !== void 0 ? _b : core.MAX_KEY),\n                    ];\n                };\n                const readSubscribers = {\n                    get: (req) => [primaryKey, new RangeSet(req.key)],\n                    getMany: (req) => [primaryKey, new RangeSet().addKeys(req.keys)],\n                    count: getRange,\n                    query: getRange,\n                    openCursor: getRange,\n                };\n                keys(readSubscribers).forEach(method => {\n                    tableClone[method] = function (req) {\n                        const { subscr } = PSD;\n                        if (subscr) {\n                            const getRangeSet = (indexName) => {\n                                const part = `idb://${dbName}/${tableName}/${indexName}`;\n                                return (subscr[part] ||\n                                    (subscr[part] = new RangeSet()));\n                            };\n                            const pkRangeSet = getRangeSet(\"\");\n                            const delsRangeSet = getRangeSet(\":dels\");\n                            const [queriedIndex, queriedRanges] = readSubscribers[method](req);\n                            getRangeSet(queriedIndex.name || \"\").add(queriedRanges);\n                            if (!queriedIndex.isPrimaryKey) {\n                                if (method === \"count\") {\n                                    delsRangeSet.add(FULL_RANGE);\n                                }\n                                else {\n                                    const keysPromise = method === \"query\" &&\n                                        outbound &&\n                                        req.values &&\n                                        table.query({\n                                            ...req,\n                                            values: false,\n                                        });\n                                    return table[method].apply(this, arguments).then((res) => {\n                                        if (method === \"query\") {\n                                            if (outbound && req.values) {\n                                                return keysPromise.then(({ result: resultingKeys }) => {\n                                                    pkRangeSet.addKeys(resultingKeys);\n                                                    return res;\n                                                });\n                                            }\n                                            const pKeys = req.values\n                                                ? res.result.map(extractKey)\n                                                : res.result;\n                                            if (req.values) {\n                                                pkRangeSet.addKeys(pKeys);\n                                            }\n                                            else {\n                                                delsRangeSet.addKeys(pKeys);\n                                            }\n                                        }\n                                        else if (method === \"openCursor\") {\n                                            const cursor = res;\n                                            const wantValues = req.values;\n                                            return (cursor &&\n                                                Object.create(cursor, {\n                                                    key: {\n                                                        get() {\n                                                            delsRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.key;\n                                                        },\n                                                    },\n                                                    primaryKey: {\n                                                        get() {\n                                                            const pkey = cursor.primaryKey;\n                                                            delsRangeSet.addKey(pkey);\n                                                            return pkey;\n                                                        },\n                                                    },\n                                                    value: {\n                                                        get() {\n                                                            wantValues && pkRangeSet.addKey(cursor.primaryKey);\n                                                            return cursor.value;\n                                                        },\n                                                    },\n                                                }));\n                                        }\n                                        return res;\n                                    });\n                                }\n                            }\n                        }\n                        return table[method].apply(this, arguments);\n                    };\n                });\n                return tableClone;\n            },\n        };\n    },\n};\nfunction trackAffectedIndexes(getRangeSet, schema, oldObjs, newObjs) {\n    function addAffectedIndex(ix) {\n        const rangeSet = getRangeSet(ix.name || \"\");\n        function extractKey(obj) {\n            return obj != null ? ix.extractKey(obj) : null;\n        }\n        const addKeyOrKeys = (key) => ix.multiEntry && isArray(key)\n            ? key.forEach(key => rangeSet.addKey(key))\n            : rangeSet.addKey(key);\n        (oldObjs || newObjs).forEach((_, i) => {\n            const oldKey = oldObjs && extractKey(oldObjs[i]);\n            const newKey = newObjs && extractKey(newObjs[i]);\n            if (cmp(oldKey, newKey) !== 0) {\n                if (oldKey != null)\n                    addKeyOrKeys(oldKey);\n                if (newKey != null)\n                    addKeyOrKeys(newKey);\n            }\n        });\n    }\n    schema.indexes.forEach(addAffectedIndex);\n}\n\nclass Dexie$1 {\n    constructor(name, options) {\n        this._middlewares = {};\n        this.verno = 0;\n        const deps = Dexie$1.dependencies;\n        this._options = options = {\n            addons: Dexie$1.addons,\n            autoOpen: true,\n            indexedDB: deps.indexedDB,\n            IDBKeyRange: deps.IDBKeyRange,\n            ...options\n        };\n        this._deps = {\n            indexedDB: options.indexedDB,\n            IDBKeyRange: options.IDBKeyRange\n        };\n        const { addons, } = options;\n        this._dbSchema = {};\n        this._versions = [];\n        this._storeNames = [];\n        this._allTables = {};\n        this.idbdb = null;\n        this._novip = this;\n        const state = {\n            dbOpenError: null,\n            isBeingOpened: false,\n            onReadyBeingFired: null,\n            openComplete: false,\n            dbReadyResolve: nop,\n            dbReadyPromise: null,\n            cancelOpen: nop,\n            openCanceller: null,\n            autoSchema: true\n        };\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n        this._state = state;\n        this.name = name;\n        this.on = Events(this, \"populate\", \"blocked\", \"versionchange\", \"close\", { ready: [promisableChain, nop] });\n        this.on.ready.subscribe = override(this.on.ready.subscribe, subscribe => {\n            return (subscriber, bSticky) => {\n                Dexie$1.vip(() => {\n                    const state = this._state;\n                    if (state.openComplete) {\n                        if (!state.dbOpenError)\n                            DexiePromise.resolve().then(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else if (state.onReadyBeingFired) {\n                        state.onReadyBeingFired.push(subscriber);\n                        if (bSticky)\n                            subscribe(subscriber);\n                    }\n                    else {\n                        subscribe(subscriber);\n                        const db = this;\n                        if (!bSticky)\n                            subscribe(function unsubscribe() {\n                                db.on.ready.unsubscribe(subscriber);\n                                db.on.ready.unsubscribe(unsubscribe);\n                            });\n                    }\n                });\n            };\n        });\n        this.Collection = createCollectionConstructor(this);\n        this.Table = createTableConstructor(this);\n        this.Transaction = createTransactionConstructor(this);\n        this.Version = createVersionConstructor(this);\n        this.WhereClause = createWhereClauseConstructor(this);\n        this.on(\"versionchange\", ev => {\n            if (ev.newVersion > 0)\n                console.warn(`Another connection wants to upgrade database '${this.name}'. Closing db now to resume the upgrade.`);\n            else\n                console.warn(`Another connection wants to delete database '${this.name}'. Closing db now to resume the delete request.`);\n            this.close();\n        });\n        this.on(\"blocked\", ev => {\n            if (!ev.newVersion || ev.newVersion < ev.oldVersion)\n                console.warn(`Dexie.delete('${this.name}') was blocked`);\n            else\n                console.warn(`Upgrade '${this.name}' blocked by other connection holding version ${ev.oldVersion / 10}`);\n        });\n        this._maxKey = getMaxKey(options.IDBKeyRange);\n        this._createTransaction = (mode, storeNames, dbschema, parentTransaction) => new this.Transaction(mode, storeNames, dbschema, this._options.chromeTransactionDurability, parentTransaction);\n        this._fireOnBlocked = ev => {\n            this.on(\"blocked\").fire(ev);\n            connections\n                .filter(c => c.name === this.name && c !== this && !c._state.vcFired)\n                .map(c => c.on(\"versionchange\").fire(ev));\n        };\n        this.use(virtualIndexMiddleware);\n        this.use(hooksMiddleware);\n        this.use(observabilityMiddleware);\n        this.use(cacheExistingValuesMiddleware);\n        this.vip = Object.create(this, { _vip: { value: true } });\n        addons.forEach(addon => addon(this));\n    }\n    version(versionNumber) {\n        if (isNaN(versionNumber) || versionNumber < 0.1)\n            throw new exceptions.Type(`Given version is not a positive number`);\n        versionNumber = Math.round(versionNumber * 10) / 10;\n        if (this.idbdb || this._state.isBeingOpened)\n            throw new exceptions.Schema(\"Cannot add version when database is open\");\n        this.verno = Math.max(this.verno, versionNumber);\n        const versions = this._versions;\n        var versionInstance = versions.filter(v => v._cfg.version === versionNumber)[0];\n        if (versionInstance)\n            return versionInstance;\n        versionInstance = new this.Version(versionNumber);\n        versions.push(versionInstance);\n        versions.sort(lowerVersionFirst);\n        versionInstance.stores({});\n        this._state.autoSchema = false;\n        return versionInstance;\n    }\n    _whenReady(fn) {\n        return (this.idbdb && (this._state.openComplete || PSD.letThrough || this._vip)) ? fn() : new DexiePromise((resolve, reject) => {\n            if (this._state.openComplete) {\n                return reject(new exceptions.DatabaseClosed(this._state.dbOpenError));\n            }\n            if (!this._state.isBeingOpened) {\n                if (!this._options.autoOpen) {\n                    reject(new exceptions.DatabaseClosed());\n                    return;\n                }\n                this.open().catch(nop);\n            }\n            this._state.dbReadyPromise.then(resolve, reject);\n        }).then(fn);\n    }\n    use({ stack, create, level, name }) {\n        if (name)\n            this.unuse({ stack, name });\n        const middlewares = this._middlewares[stack] || (this._middlewares[stack] = []);\n        middlewares.push({ stack, create, level: level == null ? 10 : level, name });\n        middlewares.sort((a, b) => a.level - b.level);\n        return this;\n    }\n    unuse({ stack, name, create }) {\n        if (stack && this._middlewares[stack]) {\n            this._middlewares[stack] = this._middlewares[stack].filter(mw => create ? mw.create !== create :\n                name ? mw.name !== name :\n                    false);\n        }\n        return this;\n    }\n    open() {\n        return dexieOpen(this);\n    }\n    _close() {\n        const state = this._state;\n        const idx = connections.indexOf(this);\n        if (idx >= 0)\n            connections.splice(idx, 1);\n        if (this.idbdb) {\n            try {\n                this.idbdb.close();\n            }\n            catch (e) { }\n            this._novip.idbdb = null;\n        }\n        state.dbReadyPromise = new DexiePromise(resolve => {\n            state.dbReadyResolve = resolve;\n        });\n        state.openCanceller = new DexiePromise((_, reject) => {\n            state.cancelOpen = reject;\n        });\n    }\n    close() {\n        this._close();\n        const state = this._state;\n        this._options.autoOpen = false;\n        state.dbOpenError = new exceptions.DatabaseClosed();\n        if (state.isBeingOpened)\n            state.cancelOpen(state.dbOpenError);\n    }\n    delete() {\n        const hasArguments = arguments.length > 0;\n        const state = this._state;\n        return new DexiePromise((resolve, reject) => {\n            const doDelete = () => {\n                this.close();\n                var req = this._deps.indexedDB.deleteDatabase(this.name);\n                req.onsuccess = wrap(() => {\n                    _onDatabaseDeleted(this._deps, this.name);\n                    resolve();\n                });\n                req.onerror = eventRejectHandler(reject);\n                req.onblocked = this._fireOnBlocked;\n            };\n            if (hasArguments)\n                throw new exceptions.InvalidArgument(\"Arguments not allowed in db.delete()\");\n            if (state.isBeingOpened) {\n                state.dbReadyPromise.then(doDelete);\n            }\n            else {\n                doDelete();\n            }\n        });\n    }\n    backendDB() {\n        return this.idbdb;\n    }\n    isOpen() {\n        return this.idbdb !== null;\n    }\n    hasBeenClosed() {\n        const dbOpenError = this._state.dbOpenError;\n        return dbOpenError && (dbOpenError.name === 'DatabaseClosed');\n    }\n    hasFailed() {\n        return this._state.dbOpenError !== null;\n    }\n    dynamicallyOpened() {\n        return this._state.autoSchema;\n    }\n    get tables() {\n        return keys(this._allTables).map(name => this._allTables[name]);\n    }\n    transaction() {\n        const args = extractTransactionArgs.apply(this, arguments);\n        return this._transaction.apply(this, args);\n    }\n    _transaction(mode, tables, scopeFunc) {\n        let parentTransaction = PSD.trans;\n        if (!parentTransaction || parentTransaction.db !== this || mode.indexOf('!') !== -1)\n            parentTransaction = null;\n        const onlyIfCompatible = mode.indexOf('?') !== -1;\n        mode = mode.replace('!', '').replace('?', '');\n        let idbMode, storeNames;\n        try {\n            storeNames = tables.map(table => {\n                var storeName = table instanceof this.Table ? table.name : table;\n                if (typeof storeName !== 'string')\n                    throw new TypeError(\"Invalid table argument to Dexie.transaction(). Only Table or String are allowed\");\n                return storeName;\n            });\n            if (mode == \"r\" || mode === READONLY)\n                idbMode = READONLY;\n            else if (mode == \"rw\" || mode == READWRITE)\n                idbMode = READWRITE;\n            else\n                throw new exceptions.InvalidArgument(\"Invalid transaction mode: \" + mode);\n            if (parentTransaction) {\n                if (parentTransaction.mode === READONLY && idbMode === READWRITE) {\n                    if (onlyIfCompatible) {\n                        parentTransaction = null;\n                    }\n                    else\n                        throw new exceptions.SubTransaction(\"Cannot enter a sub-transaction with READWRITE mode when parent transaction is READONLY\");\n                }\n                if (parentTransaction) {\n                    storeNames.forEach(storeName => {\n                        if (parentTransaction && parentTransaction.storeNames.indexOf(storeName) === -1) {\n                            if (onlyIfCompatible) {\n                                parentTransaction = null;\n                            }\n                            else\n                                throw new exceptions.SubTransaction(\"Table \" + storeName +\n                                    \" not included in parent transaction.\");\n                        }\n                    });\n                }\n                if (onlyIfCompatible && parentTransaction && !parentTransaction.active) {\n                    parentTransaction = null;\n                }\n            }\n        }\n        catch (e) {\n            return parentTransaction ?\n                parentTransaction._promise(null, (_, reject) => { reject(e); }) :\n                rejection(e);\n        }\n        const enterTransaction = enterTransactionScope.bind(null, this, idbMode, storeNames, parentTransaction, scopeFunc);\n        return (parentTransaction ?\n            parentTransaction._promise(idbMode, enterTransaction, \"lock\") :\n            PSD.trans ?\n                usePSD(PSD.transless, () => this._whenReady(enterTransaction)) :\n                this._whenReady(enterTransaction));\n    }\n    table(tableName) {\n        if (!hasOwn(this._allTables, tableName)) {\n            throw new exceptions.InvalidTable(`Table ${tableName} does not exist`);\n        }\n        return this._allTables[tableName];\n    }\n}\n\nconst symbolObservable = typeof Symbol !== \"undefined\" && \"observable\" in Symbol\n    ? Symbol.observable\n    : \"@@observable\";\nclass Observable {\n    constructor(subscribe) {\n        this._subscribe = subscribe;\n    }\n    subscribe(x, error, complete) {\n        return this._subscribe(!x || typeof x === \"function\" ? { next: x, error, complete } : x);\n    }\n    [symbolObservable]() {\n        return this;\n    }\n}\n\nfunction extendObservabilitySet(target, newSet) {\n    keys(newSet).forEach(part => {\n        const rangeSet = target[part] || (target[part] = new RangeSet());\n        mergeRanges(rangeSet, newSet[part]);\n    });\n    return target;\n}\n\nfunction liveQuery(querier) {\n    return new Observable((observer) => {\n        const scopeFuncIsAsync = isAsyncFunction(querier);\n        function execute(subscr) {\n            if (scopeFuncIsAsync) {\n                incrementExpectedAwaits();\n            }\n            const exec = () => newScope(querier, { subscr, trans: null });\n            const rv = PSD.trans\n                ?\n                    usePSD(PSD.transless, exec)\n                : exec();\n            if (scopeFuncIsAsync) {\n                rv.then(decrementExpectedAwaits, decrementExpectedAwaits);\n            }\n            return rv;\n        }\n        let closed = false;\n        let accumMuts = {};\n        let currentObs = {};\n        const subscription = {\n            get closed() {\n                return closed;\n            },\n            unsubscribe: () => {\n                closed = true;\n                globalEvents.storagemutated.unsubscribe(mutationListener);\n            },\n        };\n        observer.start && observer.start(subscription);\n        let querying = false, startedListening = false;\n        function shouldNotify() {\n            return keys(currentObs).some((key) => accumMuts[key] && rangesOverlap(accumMuts[key], currentObs[key]));\n        }\n        const mutationListener = (parts) => {\n            extendObservabilitySet(accumMuts, parts);\n            if (shouldNotify()) {\n                doQuery();\n            }\n        };\n        const doQuery = () => {\n            if (querying || closed)\n                return;\n            accumMuts = {};\n            const subscr = {};\n            const ret = execute(subscr);\n            if (!startedListening) {\n                globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, mutationListener);\n                startedListening = true;\n            }\n            querying = true;\n            Promise.resolve(ret).then((result) => {\n                querying = false;\n                if (closed)\n                    return;\n                if (shouldNotify()) {\n                    doQuery();\n                }\n                else {\n                    accumMuts = {};\n                    currentObs = subscr;\n                    observer.next && observer.next(result);\n                }\n            }, (err) => {\n                querying = false;\n                observer.error && observer.error(err);\n                subscription.unsubscribe();\n            });\n        };\n        doQuery();\n        return subscription;\n    });\n}\n\nlet domDeps;\ntry {\n    domDeps = {\n        indexedDB: _global.indexedDB || _global.mozIndexedDB || _global.webkitIndexedDB || _global.msIndexedDB,\n        IDBKeyRange: _global.IDBKeyRange || _global.webkitIDBKeyRange\n    };\n}\ncatch (e) {\n    domDeps = { indexedDB: null, IDBKeyRange: null };\n}\n\nconst Dexie = Dexie$1;\nprops(Dexie, {\n    ...fullNameExceptions,\n    delete(databaseName) {\n        const db = new Dexie(databaseName, { addons: [] });\n        return db.delete();\n    },\n    exists(name) {\n        return new Dexie(name, { addons: [] }).open().then(db => {\n            db.close();\n            return true;\n        }).catch('NoSuchDatabaseError', () => false);\n    },\n    getDatabaseNames(cb) {\n        try {\n            return getDatabaseNames(Dexie.dependencies).then(cb);\n        }\n        catch (_a) {\n            return rejection(new exceptions.MissingAPI());\n        }\n    },\n    defineClass() {\n        function Class(content) {\n            extend(this, content);\n        }\n        return Class;\n    },\n    ignoreTransaction(scopeFunc) {\n        return PSD.trans ?\n            usePSD(PSD.transless, scopeFunc) :\n            scopeFunc();\n    },\n    vip,\n    async: function (generatorFn) {\n        return function () {\n            try {\n                var rv = awaitIterator(generatorFn.apply(this, arguments));\n                if (!rv || typeof rv.then !== 'function')\n                    return DexiePromise.resolve(rv);\n                return rv;\n            }\n            catch (e) {\n                return rejection(e);\n            }\n        };\n    },\n    spawn: function (generatorFn, args, thiz) {\n        try {\n            var rv = awaitIterator(generatorFn.apply(thiz, args || []));\n            if (!rv || typeof rv.then !== 'function')\n                return DexiePromise.resolve(rv);\n            return rv;\n        }\n        catch (e) {\n            return rejection(e);\n        }\n    },\n    currentTransaction: {\n        get: () => PSD.trans || null\n    },\n    waitFor: function (promiseOrFunction, optionalTimeout) {\n        const promise = DexiePromise.resolve(typeof promiseOrFunction === 'function' ?\n            Dexie.ignoreTransaction(promiseOrFunction) :\n            promiseOrFunction)\n            .timeout(optionalTimeout || 60000);\n        return PSD.trans ?\n            PSD.trans.waitFor(promise) :\n            promise;\n    },\n    Promise: DexiePromise,\n    debug: {\n        get: () => debug,\n        set: value => {\n            setDebug(value, value === 'dexie' ? () => true : dexieStackFrameFilter);\n        }\n    },\n    derive: derive,\n    extend: extend,\n    props: props,\n    override: override,\n    Events: Events,\n    on: globalEvents,\n    liveQuery,\n    extendObservabilitySet,\n    getByKeyPath: getByKeyPath,\n    setByKeyPath: setByKeyPath,\n    delByKeyPath: delByKeyPath,\n    shallowClone: shallowClone,\n    deepClone: deepClone,\n    getObjectDiff: getObjectDiff,\n    cmp,\n    asap: asap$1,\n    minKey: minKey,\n    addons: [],\n    connections: connections,\n    errnames: errnames,\n    dependencies: domDeps,\n    semVer: DEXIE_VERSION,\n    version: DEXIE_VERSION.split('.')\n        .map(n => parseInt(n))\n        .reduce((p, c, i) => p + (c / Math.pow(10, i * 2))),\n});\nDexie.maxKey = getMaxKey(Dexie.dependencies.IDBKeyRange);\n\nif (typeof dispatchEvent !== 'undefined' && typeof addEventListener !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, updatedParts => {\n        if (!propagatingLocally) {\n            let event;\n            if (isIEOrEdge) {\n                event = document.createEvent('CustomEvent');\n                event.initCustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, true, true, updatedParts);\n            }\n            else {\n                event = new CustomEvent(STORAGE_MUTATED_DOM_EVENT_NAME, {\n                    detail: updatedParts\n                });\n            }\n            propagatingLocally = true;\n            dispatchEvent(event);\n            propagatingLocally = false;\n        }\n    });\n    addEventListener(STORAGE_MUTATED_DOM_EVENT_NAME, ({ detail }) => {\n        if (!propagatingLocally) {\n            propagateLocally(detail);\n        }\n    });\n}\nfunction propagateLocally(updateParts) {\n    let wasMe = propagatingLocally;\n    try {\n        propagatingLocally = true;\n        globalEvents.storagemutated.fire(updateParts);\n    }\n    finally {\n        propagatingLocally = wasMe;\n    }\n}\nlet propagatingLocally = false;\n\nif (typeof BroadcastChannel !== 'undefined') {\n    const bc = new BroadcastChannel(STORAGE_MUTATED_DOM_EVENT_NAME);\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        if (!propagatingLocally) {\n            bc.postMessage(changedParts);\n        }\n    });\n    bc.onmessage = (ev) => {\n        if (ev.data)\n            propagateLocally(ev.data);\n    };\n}\nelse if (typeof self !== 'undefined' && typeof navigator !== 'undefined') {\n    globalEvents(DEXIE_STORAGE_MUTATED_EVENT_NAME, (changedParts) => {\n        try {\n            if (!propagatingLocally) {\n                if (typeof localStorage !== 'undefined') {\n                    localStorage.setItem(STORAGE_MUTATED_DOM_EVENT_NAME, JSON.stringify({\n                        trig: Math.random(),\n                        changedParts,\n                    }));\n                }\n                if (typeof self['clients'] === 'object') {\n                    [...self['clients'].matchAll({ includeUncontrolled: true })].forEach((client) => client.postMessage({\n                        type: STORAGE_MUTATED_DOM_EVENT_NAME,\n                        changedParts,\n                    }));\n                }\n            }\n        }\n        catch (_a) { }\n    });\n    addEventListener('storage', (ev) => {\n        if (ev.key === STORAGE_MUTATED_DOM_EVENT_NAME) {\n            const data = JSON.parse(ev.newValue);\n            if (data)\n                propagateLocally(data.changedParts);\n        }\n    });\n    const swContainer = self.document && navigator.serviceWorker;\n    if (swContainer) {\n        swContainer.addEventListener('message', propagateMessageLocally);\n    }\n}\nfunction propagateMessageLocally({ data }) {\n    if (data && data.type === STORAGE_MUTATED_DOM_EVENT_NAME) {\n        propagateLocally(data.changedParts);\n    }\n}\n\nDexiePromise.rejectionMapper = mapError;\nsetDebug(debug, dexieStackFrameFilter);\n\nexport { Dexie$1 as Dexie, RangeSet, Dexie$1 as default, liveQuery, mergeRanges, rangesOverlap };\n//# sourceMappingURL=dexie.mjs.map\n","import Dexie from 'dexie';\nlet _repoid = null;\nlet _repoLabel = null;\nlet _binderRefUrl = null;\nlet _binderPersistentUrl = null;\nlet db = null;\nconst dbname = 'jupyter-offlinenotebook';\nclass OfflinenotebookDatabase extends Dexie {\n    constructor() {\n        super(dbname);\n        // Define tables and indexes\n        this.version(1).stores({\n            offlinenotebook: 'pk, repoid, name, type',\n        });\n        // The following lines are needed for it to work across typescipt using babel-preset-typescript:\n        this.offlinenotebook = this.table('offlinenotebook');\n    }\n}\nexport function initialise(data) {\n    _repoid = data['repoid'];\n    if (_repoid) {\n        console.log('offline-notebook repoid: ' + _repoid);\n    }\n    else {\n        console.log('offline-notebook repoid not found, disabled');\n    }\n    _repoLabel = data['binder_repo_label'] || 'Repo';\n    console.log('offline-notebook repoLabel: ' + _repoLabel);\n    _binderRefUrl = data['binder_ref_url'];\n    console.log('offline-notebook binderRefUrl: ' + _binderRefUrl);\n    _binderPersistentUrl = data['binder_persistent_url'];\n    console.log('offline-notebook binderPersistentUrl: ' + _binderPersistentUrl);\n}\nfunction getDb() {\n    if (!db) {\n        db = new OfflinenotebookDatabase();\n        console.log('offline-notebook: Opened IndexedDB');\n    }\n    return db;\n}\nexport function saveNotebook(path, nb, success, error) {\n    const primaryKey = 'repoid:' + _repoid + ' path:' + path;\n    getDb()\n        .offlinenotebook.put({\n        pk: primaryKey,\n        repoid: _repoid,\n        name: path.replace(/.*\\//, ''),\n        path: path,\n        format: 'json',\n        type: 'notebook',\n        content: nb,\n    })\n        .then((key) => success(key))\n        .catch((e) => error(e));\n}\nexport function loadNotebook(path, success, error) {\n    const primaryKey = 'repoid:' + _repoid + ' path:' + path;\n    getDb()\n        .offlinenotebook.get(primaryKey)\n        .then((key) => success(key))\n        .catch((e) => error(e));\n}\n// Download https://jsfiddle.net/koldev/cW7W5/\nexport function downloadNotebookFromBrowser(name, nb) {\n    const blob = new Blob([JSON.stringify(nb)], {\n        // https://jupyter.readthedocs.io/en/latest/reference/mimetype.html\n        type: 'application/x-ipynb+json',\n    });\n    const url = window.URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.href = url;\n    a.style.display = 'none';\n    a.download = name;\n    console.log('offlinenotebook: ' + name, blob);\n    a.click();\n    window.URL.revokeObjectURL(url);\n    document.body.removeChild(a);\n}\nexport function openBinderRepo() {\n    const a = document.createElement('a');\n    document.body.appendChild(a);\n    a.href = _binderRefUrl;\n    a.target = '_blank';\n    a.style.display = 'none';\n    a.click();\n    document.body.removeChild(a);\n}\nexport function repoid() {\n    return _repoid;\n}\nexport function repoLabel() {\n    return _repoLabel;\n}\nexport function binderRefUrl() {\n    return _binderRefUrl;\n}\nexport function binderPersistentUrl() {\n    return _binderPersistentUrl;\n}\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","_global","globalThis","self","window","global","keys","isArray","Array","extend","extension","forEach","Promise","getProto","getPrototypeOf","_hasOwn","hasOwn","props","proto","Reflect","ownKeys","setProp","functionOrGetSet","options","set","configurable","writable","derive","Child","from","Parent","create","bind","getOwnPropertyDescriptor","getPropertyDescriptor","_slice","slice","args","start","end","override","origFunc","overridedFactory","assert","b","Error","asap$1","fn","setImmediate","setTimeout","arrayToObject","array","extractor","reduce","result","item","i","nameAndValue","getByKeyPath","keyPath","rv","l","length","val","push","period","indexOf","innerObj","substr","undefined","setByKeyPath","isFrozen","currentKeyPath","remainingKeyPath","isNaN","parseInt","splice","shallowClone","m","concat","flatten","a","apply","intrinsicTypeNames","split","map","num","t","filter","intrinsicTypes","x","circularRefs","deepClone","any","WeakMap","innerDeepClone","constructor","toString","iteratorSymbol","iterator","getIteratorOf","NO_CHAR_ARRAY","getArrayOf","arrayLike","it","arguments","this","next","done","isAsyncFunction","debug","location","test","href","setDebug","libraryFilter","NEEDS_THROW_FOR_STACK","stack","getErrorWithStack","e","prettyStack","exception","numIgnoredFrames","name","message","frame","join","idbDomErrorNames","errorList","defaultTexts","VersionChanged","DatabaseClosed","Abort","TransactionInactive","MissingAPI","DexieError","msg","_e","getMultiErrorMessage","failures","v","s","ModifyError","successCount","failedKeys","BulkError","pos","failuresByPos","_stack","errnames","BaseException","exceptions","fullName","msgOrInner","inner","Syntax","SyntaxError","Type","TypeError","Range","RangeError","exceptionMap","fullNameExceptions","nop","mirror","pureFunctionChain","f1","f2","callBoth","on1","on2","hookCreatingChain","res","onsuccess","onerror","res2","hookDeletingChain","hookUpdatingChain","modifications","reverseStoppableEventChain","promisableChain","then","thiz","INTERNAL","resolvedNativePromise","nativePromiseProto","resolvedGlobalPromise","globalP","resolve","crypto","subtle","nativeP","digest","Uint8Array","nativePromiseThen","NativePromise","patchGlobalPromise","stack_being_generated","schedulePhysicalTick","physicalTick","MutationObserver","hiddenDiv","document","createElement","observe","attributes","setAttribute","asap","callback","microtickQueue","needsNewPhysicalTick","isOutsideMicroTick","unhandledErrors","rejectingErrors","currentFulfiller","rejectionMapper","globalPSD","id","ref","unhandleds","onunhandled","globalError","pgp","env","finalize","uh","PSD","numScheduledCalls","tickFinalizers","DexiePromise","_listeners","onuncatched","_lib","psd","_PSD","_stackHolder","_prev","_numPrev","_state","_value","handleRejection","executePromiseTask","thenProp","microTaskId","totalEchoes","onFulfilled","onRejected","possibleAwait","cleanup","decrementExpectedAwaits","reject","propagateToListener","Listener","nativeAwaitCompatibleWrap","linkToPreviousPromise","zone","promise","shouldExecuteTick","beginMicroTickScope","_then","propagateAllListeners","endMicroTickScope","ex","reason","_promise","origProp","tryCatch","some","p","addPossiblyUnhandledError","listeners","len","finalizePhysicalTick","listener","cb","callListener","ret","markErrorAsHandled","getStack","stacks","limit","errorName","failure","prev","numPrev","wasRootExec","callbacks","unhandledErrs","finalizers","PromiseReject","wrap","errorCatcher","outerScope","switchToZone","catch","type","handler","err","finally","onFinally","timeout","ms","Infinity","handle","Timeout","clearTimeout","snapShot","all","values","onPossibleParallellAsync","remaining","race","newPSD","newScope","usePSD","scheduler","follow","zoneProps","finalizer","run_at_end_of_this_or_next_physical_tick","allSettled","possiblePromises","results","status","AggregateError","task","awaits","echoes","taskCounter","zoneStack","zoneEchoes","zone_id_counter","a1","a2","parent","globalEnv","PromiseProp","nthen","getPatchedPromiseThen","gthen","incrementExpectedAwaits","possiblePromise","rejection","zoneEnterEcho","targetZone","zoneLeaveEcho","pop","bEnteringZone","currentZone","enqueueNativeMicroTask","GlobalPromise","targetEnv","a3","job","outerZone","origThen","onResolved","UNHANDLEDREJECTION","event","eventData","createEvent","initEvent","CustomEvent","detail","dispatchEvent","PromiseRejectionEvent","onunhandledrejection","_","defaultPrevented","console","warn","tempTransaction","db","mode","storeNames","idbdb","openComplete","letThrough","_vip","trans","_createTransaction","_dbSchema","_completion","dbOpenError","isBeingOpened","_options","autoOpen","open","dbReadyPromise","DEXIE_VERSION","maxString","String","fromCharCode","minKey","INVALID_KEY_ARGUMENT","STRING_EXPECTED","connections","isIEOrEdge","navigator","userAgent","hasIEDeleteObjectStoreBug","hangsOnDeleteLargeKeyRange","dexieStackFrameFilter","DBNAMES_DB","READONLY","READWRITE","combine","filter1","filter2","AnyRange","lower","lowerOpen","upper","upperOpen","workaroundForUndefinedPrimKey","Table","_trans","writeLocked","_tx","tableName","checkTableInTransaction","schema","NotFound","idbtrans","transless","keyOrCrit","where","first","core","hook","reading","fire","indexOrCrit","WhereClause","keyPaths","equals","compoundIndex","indexes","primKey","ix","compound","every","_maxKey","kp","JSON","stringify","idxByName","idb","_deps","indexedDB","cmp","idx","filterFunction","prevIndex","prevFilterFn","index","multi","toCollection","and","count","thenShortcut","offset","numRows","each","toArray","Collection","orderBy","reverse","mapToClass","mappedClass","readHook","unsubscribe","defineClass","content","add","auto","objToAdd","mutate","numFailures","lastResult","update","keyOrObject","modify","InvalidArgument","_a","put","delete","clear","range","bulkGet","getMany","bulkAdd","objects","keysOrOptions","wantResults","allKeys","numObjects","objectsToAdd","bulkPut","objectsToPut","bulkDelete","numKeys","Events","ctx","evs","eventName","subscriber","subscribe","addEventType","chainFunction","defaultFunction","addConfiguredEvents","context","subscribers","cfg","makeClassConstructor","isPlainKeyRange","ignoreLimitFilter","algorithm","or","justLimit","replayFilter","addFilter","addReplayFilter","factory","isLimitFilter","curr","getIndexOrStore","coreSchema","isPrimKey","primaryKey","getIndexByKeyPath","Schema","openCursor","coreTable","keysOnly","dir","unique","query","iter","coreTrans","union","cursor","advance","stop","fail","_iterate","iterate","valueMapper","cursorPromise","wrappedFn","c","continue","advancer","ta","tb","NaN","al","bl","compareUint8Arrays","getUint8Array","compareArrays","ArrayBuffer","isView","tsTag","buffer","byteOffset","byteLength","_read","_ctx","error","table","_write","_addAlgorithm","clone","raw","Math","min","sortBy","parts","lastPart","lastIndex","getval","order","sorter","aVal","bVal","sort","offsetLeft","rowsLeft","until","bIncludeStopEntry","last","isMatch","indexName","_ondirectionchange","desc","eachKey","eachUniqueKey","eachPrimaryKey","primaryKeys","uniqueKeys","firstKey","lastKey","distinct","strKey","found","changes","modifyer","anythingModified","outbound","extractKey","modifyChunkSize","totalFailures","applyMutateResult","expectedCount","nextChunk","cache","addValues","putValues","putKeys","deleteKeys","origValue","criteria","deleteCallback","changeSpec","coreRange","simpleCompare","simpleCompareReverse","collectionOrWhereClause","T","collection","emptyCollection","whereClause","rangeEqual","nextCasing","lowerKey","upperNeedle","lowerNeedle","llp","lwrKeyChar","addIgnoreCaseAlgorithm","match","needles","suffix","compare","upperNeedles","lowerNeedles","direction","nextKeySuffix","needlesLen","initDirection","toUpperCase","toLowerCase","upperFactory","lowerFactory","needleBounds","needle","nb","createRange","firstPossibleNeedle","lowestPossibleCasing","casing","between","includeLower","includeUpper","_cmp","above","aboveOrEqual","below","belowOrEqual","startsWith","str","startsWithIgnoreCase","equalsIgnoreCase","anyOfIgnoreCase","startsWithAnyOfIgnoreCase","n","anyOf","_ascending","_descending","notEqual","inAnyRange","includeLowers","includeUppers","noneOf","ranges","ascending","descending","_min","max","_max","sortDirection","rangeSorter","newRange","rangePos","keyIsBeyondCurrentEntry","keyIsBeforeCurrentEntry","checkKey","keyWithinCurrentRange","startsWithAnyOf","eventRejectHandler","preventDefault","target","stopPropagation","DEXIE_STORAGE_MUTATED_EVENT_NAME","STORAGE_MUTATED_DOM_EVENT_NAME","globalEvents","Transaction","_lock","_reculock","lockOwnerFor","_unlock","_blockedFuncs","_locked","fnAndPSD","shift","OpenFailed","active","transaction","durability","chromeTransactionDurability","ev","_reject","onabort","on","oncomplete","_resolve","storagemutated","bWriteLock","ReadOnly","_root","waitFor","promiseLike","root","_waitingFor","_waitingQueue","store","objectStore","spin","_spinCount","currentWaitPromise","abort","memoizedTables","_memoizedTables","tableSchema","transactionBoundTable","createIndexSpec","src","nameFromKeyPath","createTableSchema","getMaxKey","IdbKeyRange","only","getKeyExtractor","getSinglePathKeyExtractor","arrayify","_id_counter","getKeyPathAlias","generateMiddlewareStacks","_novip","tmpTrans","middlewares","IDBKeyRange","dbcore","stackImpl","down","createMiddlewareStack","makeIDBKeyRange","upperBound","lowerBound","bound","hasGetAll","tables","objectStoreNames","autoIncrement","indexByKeyPath","isPrimaryKey","indexNames","multiEntry","extractSchema","isAddOrPut","req","reqs","errorHandler","args1","args2","keyCount","callbackCount","successHandler","_pos","request","nonInfinitLimit","source","idbKeyRange","getAll","getAllKeys","openKeyCursor","___id","_cursorContinue","_cursorContinuePrimaryKey","continuePrimaryKey","_cursorAdvance","doThrowCursorIsStopped","gotOne","iterationPromise","resolveIteration","rejectIteration","guardedCallback","createDbCoreTable","tableMap","MIN_KEY","MAX_KEY","createDBCore","createMiddlewareStacks","_middlewares","tbl","setApiOnPlace","objs","tableNames","dbschema","propDesc","removeTablesApi","lowerVersionFirst","_cfg","version","getSchemaDiff","oldSchema","newSchema","diff","del","change","oldDef","newDef","def","recreate","oldIndexes","newIndexes","idxName","oldIdx","newIdx","createTable","createObjectStore","addIndex","createIndex","buildGlobalSchema","globalSchema","storeName","j","idbindex","adjustToExistingIndexNames","_hasGetAll","dexieName","indexSpec","WorkerGlobalScope","Version","_parseStoresSpec","stores","outSchema","indexNum","trim","replace","storesSource","versions","_versions","storesSpec","_allTables","_storeNames","upgrade","upgradeFunction","contentUpgrade","getDbNamesTable","dbNamesDB","Dexie$1","addons","dbnames","hasDatabasesNative","databases","vip","idbReady","intervalId","userAgentData","tryIdb","setInterval","clearInterval","dexieOpen","state","openCanceller","throwIfCancelled","resolveDbReady","dbReadyResolve","upgradeTransaction","wasCreated","dbName","autoSchema","round","verno","onblocked","_fireOnBlocked","onupgradeneeded","allowEmptyDB","close","delreq","deleteDatabase","NoSuchDatabase","oldVer","oldVersion","pow","idbUpgradeTrans","rejectTransaction","populate","queue","anyContentUpgraderHasRun","tuple","Upgrade","deleteIndex","upgradeSchema","contentUpgradeIsAsync","returnValue","promiseFollowed","decrementor","deleteObjectStore","deleteRemovedTables","runQueue","contains","updateTablesAndIndexes","runUpgraders","readGlobalSchema","ch","verifyInstalledSchema","onversionchange","vcFired","onclose","_onDatabaseCreated","onReadyBeingFired","ready","fireRemainders","remainders","_close","awaitIterator","callNext","onSuccess","step","onError","throw","getNext","extractTransactionArgs","_tableArgs_","scopeFunc","enterTransactionScope","parentTransaction","scopeFuncIsAsync","PrematureCommit","pad","virtualIndexMiddleware","level","indexLookup","allVirtualIndexes","addVirtualIndexes","keyTail","lowLevelIndex","keyPathAlias","indexList","keyLength","isVirtual","virtualIndex","translateRequest","virtualCursor","createVirtualCursor","getObjectDiff","prfx","ap","bp","apTypeName","hooksMiddleware","downCore","downTable","tableMiddleware","dxTrans","deleting","creating","updating","addPutOrDelete","deleteNextChunk","deleteRange","getEffectiveKeys","effectiveKeys","getExistingValues","existingValues","contexts","existingValue","generatedPrimaryKey","objectDiff","additionalChanges","requestedValue","getFromTransactionCache","cacheExistingValuesMiddleware","cachedResult","isEmptyRange","node","RangeSet","fromOrTree","to","d","addRange","left","right","r","rebalance","rightWasCutOff","mergeRanges","newSet","_addRangeSet","getRangeSetIterator","keyProvided","up","_b","rootClone","oldRootRight","computeDepth","rangeSet","addKey","addKeys","observabilityMiddleware","FULL_RANGE","tableClone","mutatedParts","getRangeSet","part","pkRangeSet","delsRangeSet","newObjs","oldCache","oldObjs","addKeyOrKeys","oldKey","newKey","trackAffectedIndexes","getRange","readSubscribers","method","subscr","queriedIndex","queriedRanges","keysPromise","resultingKeys","pKeys","wantValues","pkey","deps","dependencies","cancelOpen","bSticky","keyRangeGenerator","keyRange","whereCtx","readingHook","createCollectionConstructor","createTableConstructor","complete","wasActive","createTransactionConstructor","versionNumber","createVersionConstructor","orCollection","_IDBKeyRange","createWhereClauseConstructor","newVersion","use","addon","versionInstance","_whenReady","unuse","mw","hasArguments","doDelete","_onDatabaseDeleted","backendDB","isOpen","hasBeenClosed","hasFailed","dynamicallyOpened","_transaction","onlyIfCompatible","idbMode","SubTransaction","enterTransaction","InvalidTable","symbolObservable","observable","Observable","_subscribe","extendObservabilitySet","domDeps","mozIndexedDB","webkitIndexedDB","msIndexedDB","webkitIDBKeyRange","Dexie","propagateLocally","updateParts","wasMe","propagatingLocally","databaseName","exists","getDatabaseNames","infos","info","ignoreTransaction","async","generatorFn","spawn","currentTransaction","promiseOrFunction","optionalTimeout","liveQuery","querier","observer","closed","accumMuts","currentObs","subscription","mutationListener","querying","startedListening","shouldNotify","rangeSet1","rangeSet2","i1","nextResult1","i2","nextResult2","rangesOverlap","doQuery","exec","execute","delByKeyPath","semVer","maxKey","addEventListener","updatedParts","initCustomEvent","BroadcastChannel","bc","changedParts","postMessage","onmessage","data","localStorage","setItem","trig","random","matchAll","includeUncontrolled","client","parse","newValue","swContainer","serviceWorker","domError","_repoid","_repoLabel","_binderRefUrl","_binderPersistentUrl","OfflinenotebookDatabase","super","offlinenotebook","initialise","log","getDb","saveNotebook","path","success","pk","repoid","format","loadNotebook","downloadNotebookFromBrowser","blob","Blob","url","URL","createObjectURL","body","appendChild","style","display","download","click","revokeObjectURL","removeChild","openBinderRepo","repoLabel","binderRefUrl","binderPersistentUrl"],"sourceRoot":""}